\documentclass[a4paper, oneside, titlepage, 12pt]{paper}
\usepackage[spanish]{babel}
\usepackage{floatrow}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{minted}
\usepackage{amsmath}
\usepackage{calc}
\usepackage{dirtree}
\usepackage{graphicx}
\usepackage[colorlinks = true,
            linkcolor = blue,
            urlcolor  = blue,
            citecolor = blue,
            anchorcolor = blue]{hyperref}
\usepackage{csquotes}
\usepackage{svg}
%esto es para que las imagenes no se vayan fuera de la seccion donde estan
\usepackage[section]{placeins} 
\usepackage{forest}
\usepackage{adjustbox}
\usepackage{alertmessage}
\graphicspath{ {./yed/} }
\svgpath{{svg/}{./yed/}}
\apptocmd{\dirtree}{\bigskip}{}{}
\pretocmd{\dirtree}{\bigskip}{}{}

\newcommand{\changeurlcolor}[1]{\hypersetup{urlcolor=#1}} 
\newcommand{\explain}[2]{\underbrace{#1}_{\parbox{\widthof{#1}}{\footnotesize\raggedright #2}}}

\floatsetup[listing]{style=Plaintop}   
%\usemintedstyle{react}
\usemintedstyle{enrique}
%\usemintedstyle{tango}
\definecolor{bg}{HTML}{282b35}
\definecolor{verylight}{RGB}{237, 236, 236}

\lstset{
basicstyle=\small, % print whole listing small
keywordstyle=\color{black}\bfseries\underbar,
identifierstyle=, % nothing happens
commentstyle=\color{white}, % white comments
stringstyle=\ttfamily, % typewriter type for strings
showstringspaces=false} % no special string spaces

 
%Esto es para que no le ponga un recuadro
%rojo a los links de la TOC
\hypersetup{%
    pdfborder = {0 0 0}
}

\title{%
	Guía de Iniciación sobre \textsc{JavaScript}\\
	\large Bases sólidas para comenzar a programar en React}
%\author{\textit{Author}\\Enrique Pablo Molinari}
\date{\today}

\begin{document}

\maketitle
\tableofcontents
		
%\chapter{Conceptos Esenciales de JavaScript}

\newpage
Si deseamos dominar React y eso significa comprender por qué y cómo funcionan ciertas cosas, debemos aprender algunos conceptos específicos de JavaScript.
\newline

En esta guía rápida explicaremos los conceptos de JavaScript y las construcciones sintácticas necesarias para crear un camino sólido que nos permitan dominar React. Si desea profundizar en más detalles sobre algunos de los temas que se explican aquí u otros sobre JavaScript, recomendamos que visiten el sitio web Mozilla \cite{mozilla}. Esta guía se basa en conceptos explicados allí.

\section{Entorno de Desarrollo}
%\addcontentsline{toc}{chapter}{Entorno de Desarrollo}

Para comenzar a programar en JavaScript y React recomendamos \href{https://code.visualstudio.com/} {Visual Studio Code} (VS Code). Y para ser más productivo, especialmente si eres nuevo en React, sugerimos que instales la extensión \href {https://marketplace.visualstudio.com/items?itemName=dsznajder.es7-react-js-snippets} {VS Code ES7 React / Redux / React-Native / JS snippets} que proporciona la generación rápida de estructuras sintácticas de JavaScript y React. También sugerímos instalar \href {https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode} {Prettier}, que es un formateador de código JavaScript / React.
\newline

Para instalar una extensión, en Visual Studio Code, vaya al menú \textsf{Archivo]}, luego \textsf{Preferencias} y luego \textsf{Extensiones}. Verá un cuadro de búsqueda que le permitirá encontrar las extensiones que desea instalar.
\newline

Finalmente, recomendamos configurar VS Code para formatear los fuentes al momento de guardar. Puede hacerlo yendo al menú \textsf{Archivo}, luego a \textsf{Preferencias} y luego a \textsf{Configuración}. En el cuadro de búsqueda, escriba Editor: Formato al guardar (Format On Save). Esto formateará su código inmediatamente después de guardarlo.

\section{Introducción}

De la web Developer Mozilla JavaScript Documentation \cite{mozilla}, JavaScript se define como:

``JavaScript (JS) es un lenguaje de programación ligero, interpretado, o compilado justo-a-tiempo (just-in-time) con funciones de primera clase. Si bien es más conocido como un lenguaje de scripting (secuencias de comandos) para páginas web, y es usado en muchos entornos fuera del navegador, tal como Node.js, Apache CouchDB y Adobe Acrobat. JavaScript es un lenguaje de programación basado en prototipos, multiparadigma, de un solo hilo, dinámico, con soporte para programación orientada a objetos, imperativa y declarativa (por ejemplo programación funcional).''
\newline

Si Usted es un desarrollador Java, C\# o C++, esta definición puede sonar un poco intimidante. Es por ésto que es necesario aprender algunos conceptos, especialmente aquellos que no están disponibles de forma natural en los lenguajes compilados. Para comenzar con esos conceptos, primero explicaremos las construcciones básicas del lenguaje, luego explicaremos lo que significa que un lenguaje tenga \textbf{funciones de primera clase} y sea \textbf {basado en prototipos}, \textbf{multi-paradigma}, \textbf{de un solo subproceso} y \textbf{dinámico}.
\newline

El lenguaje JavaScript se rige por una especificación estándar de ECMA\cite{ecma} (European Computer Manufacturers Association). ECMAScript es el nombre de la especificación. En particular, en 2015 se liberó una versión importante conocida como ES6, ECMAScript 6 o ECMAScript 2015. La mayoría de las construcciones sintácticas que estudiaremos en esta guía se implementaron en dicha versión.
\newline

Comencemos a aprender. Toda sentencia en JavaScript escrita en esta guía se ejecutará usando el intérprete de JavaScript de \textbf{nodejs}, invocándolo usando la consola de la siguiente manera:
\begin{minted}[fontseries=mc,
               framesep=2mm]{console}
$ node yourjsfile.js
\end{minted}

Utilizando Visual Studio Code, pueden abrir una consola directamente allí, desde el menú en \textsf{Terminal} y luego \textsf{Nueva Terminal}. 
\newline

Lo primero que en general aprendemos cuando nos iniciamos en un lenguaje de programación es a imprimir texto en la pantalla. Esta guía no es la excepción. Se puede imprimir texto en la pantalla usando el objeto \textit{Console} de la siguiente forma:

\begin{minted}[fontseries=mc,
               framesep=2mm,
               frame=leftline,
               linenos,
               framerule=0.1pt]{jsx}
console.log("Coding in React!");
\end{minted}

El objeto \textit{Console} se creó principalmente como herramienta de debug, no debe utilizarse en aplicaciones desplegadas en producción. No es parte parte del estándar pero todos los Browsers modernos y \textsf{nodejs} lo soportan.
\newline

\section{Variables}

Comencemos a ver como utilizamos \textbf{variables} en JavaScript. Declaramos las variables utilizando la palabra reservada \textit{let}, de la siguiente forma:

\begin{minted}[fontseries=mc,
               frame=leftline,
               linenos,
               framerule=0.1pt,
               framesep=2mm]{jsx}
let myFirstVariable;
\end{minted}

Cuando declaramos una variable sin inicializar, el intérprete la inicializará con el valor especial \textit{undefined}. Esto se puede observar si intentamos imprimir en la consola una variable no inicializada. Pruébenlo. 

\alertsuccess{Ejercicio: Declare una variable sin inicializar e imprímala en la consola.}

El siguiente ejemplo muestra cómo declarar una variable y como inicializarla a la vez.

\begin{minted}[fontseries=mc,
               framesep=2mm,
               frame=leftline,
               linenos,
               framerule=0.1pt]{jsx}
let myFirstVariable = "Hello value!";
\end{minted}

También es posible declarar una variable utilizando la palabra reservada \textit{const}:

\begin{minted}[fontseries=mc,
               framesep=2mm,
               frame=leftline,
               linenos,
               framerule=0.1pt]{jsx}
const myFirstConst = "Hello constant value!";
\end{minted}

Al declarar la variable con \textit{const} no podremos modificar su valor, si lo intentan el intérprete lanzará un error. Pruébenlo.  

\alertsuccess{Ejercicio: Declare una variable utilizando la palabra reservada \textit{const} y luego intente asignarle un nuevo valor.}

Dijimos que JavaScript es un \textbf{lenguaje dinámico}. Ésto, entre otras cosas, significa que el tipo de una variable puede cambiar en tiempo de ejecución. A diferencia de los lenguajes estáticos donde los tipos de las variables se definen durante la compilación y no pueden cambiar durante la ejecución.

\begin{minted}[fontseries=mc,
               framesep=2mm,
               frame=leftline,
               linenos,
               framerule=0.1pt]{jsx}
//mi tipo string
let changeMyType = "Hello String!";
console.log(typeof changeMyType);
//ahora es number
changeMyType = 100;
console.log(typeof changeMyType);
\end{minted}

\alertsuccess{Ejercicio: Pruebe el ejemplo anterior y revise el tipo de la variable \textsf{changeMyType} utilizando \textbf{typeof}.}.

\section{Funciones} \label{functions}

Estudiemos ahora las funciones. A continuación declaramos una función y luego la invocamos:

\begin{minted}[fontseries=mc,
               framesep=2mm,
               frame=leftline,
               linenos,
               framerule=0.1pt]{jsx}
function saySomething(string) {
  console.log(string);
}

saySomething("Hello Function!");
\end{minted}

En JavaScript podemos definir funciones que se invocan inmediatamente después de declararlas. Se denominan IIFE (Immediately-invoked Function Expression).

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               linenos,
               framerule=0.1pt]{jsx}
(function saySomething(string) {
  console.log(string);
})("Hello Function!");
\end{minted}

Las funciones siempre retornan un valor. Si se omite el uso de \textit{return} para retornar algo explícito, entonces una función retornará el valor \textit{undefined}.

\begin{minted}[fontseries=mc,
               framesep=2mm,
               frame=leftline,
               linenos,
               framerule=0.1pt]{jsx}
let x = saySomething("Hello Function!");
//x es undefined
\end{minted}

También hemos mencionado que las funciones son objetos de \textbf{primera clase}. Ésto significa que al igual que las variables, éstas pueden asignarse, pasarse por parámetro o retornarse de otra función. El ejemplo a continuación, en la línea 6, nos encontramos con una función que se asigna a la variable \colorbox{verylight}{\lstinline{say}}. Y luego en la línea 10 utilizamos esta variable para invocar la función.

\begin{minted}[fontseries=mc,
               framesep=2mm,
               frame=leftline,
               linenos,
               framerule=0.1pt]{jsx}
function returnSomething(string) {
  return "Esto es: " + string;
}

//asignando la función a una variable
let say = returnSomething;

//Invocando la función
returnSomething("Hello js!");
say("Hello again!");
\end{minted}

En el siguiente ejemplo, en la línea 12, estamos invocando una función pasando como parámetro a la función \mintinline{js}{returnSomething}. Y en la línea 8, utilizando el argumento recibido, realizamos la invocación a la función.

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               linenos]{jsx}
function returnSomething(string) {
  return "Hola: " + string;
}

//recibe una función como parámetro
//la invoca y retorna 
function saySomethingMore(fn) {
  return fn("Hey !");
}

//pasa una función como parámetro
saySomethingMore(returnSomething); //"Hola: Hey !"
\end{minted}

También podemos asignar una función a una variable directamente en su declaración, tal como se muestra a continuación:

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               linenos]{jsx}
//asignación
const returnSomething = function (string) {
  return "This is it: " + string;
};

returnSomething("Hey !"); //"This is it: Hey !"
\end{minted}

Otra forma de declarar funciones en JavaScript, de una forma algo menos verbosa, se denomina \textbf{arrow functions}. Veamos el siguiente ejemplo:

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               linenos]{jsx}
               
//arrow function sin parámetros
const arrowf1 = () => {
  return "arrowf1 was invoked!";
};

//arrow function con un parámetro
//los paréntesis no son necesarios aquí
const arrowf2 = param => {
  return "this is the argument: " + param;
};

//arrow functions con una sentencia, no necesita llaves 
//y tampoco es necesario el return, retorna solo 
const arrowf3 = (a, b) => a + b;
\end{minted}

\alertsuccess{Ejercicio: Cree una función que reciba una cadena como parámetro y devuelva la cantidad de caracteres que tiene. Utilice la función clásica con el keyword \textbf{function}. Luego implemente lo mismo pero usando una \textbf{arrow function}.}.

\section{Arreglos} \label{arrays}

Vamos a utilizar \textbf{arreglos} de forma frecuente en React en general y a lo largo de esta guía. Así es como declaramos un arreglo:

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               linenos]{jsx}
//un arreglo vacio
let empty = [];

//un arreglo de cuatro elementos
let family = ["Jóse", "Nicolas", "Lucia", "Enrique"];
\end{minted}

Los elementos de un arreglo se acceden a través de su índice, donde 0 es el primer elemento.

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               linenos]{jsx}
let family = ["Jóse", "Nicolas", "Lucia", "Enrique"];
family[0]; //Jóse
family[1]; //Nicolas
family[2]; //Lucia
family[3]; //Enrique
\end{minted}

Dado que los arreglos en JavaScript son objetos, tenemos varios métodos útiles que podremos utilizar, como el que se muestra a continuación para agregar elementos al final:

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               linenos]{jsx}

let family = ["Jóse", "Nicolas", "Lucia", "Enrique"];

//agrega un elemento al final del arreglo
family.push("Pablo");
\end{minted}

Si quisiéramos incorporar todos los elementos de un arreglo en otro arreglo, tenemos la opción de utilizar la construcción sintáctica denominada \textit{spread syntax}. Veamos cómo se utiliza:

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               linenos]{jsx}

let myParents = ["EnriqueR", "Susana"];
let JoseParents = ["Eduardo", "Graciela"];
let family = ["Jóse", "Nicolas", "Lucia", "Enrique"];
let all = [...myParents, ...JoseParents, ...family];
//[
//  'EnriqueR', 'Susana', 'Eduardo', 'Graciela', 
//  'Jóse', 'Nicolas', 'Lucia', 'Enrique'
// ]
\end{minted}

También es posible utilizar \textit{spread syntax} en los parámetros de las funciones para indicar un número indefinido de argumentos:

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               linenos]{jsx}
function restParams(param1, param2, ...params) {
 //param1 es 1	
 //param2 es 2	
 //params is [3, 4, 5]	
}

//invoco a la función restParams
restParams(1, 2, 3, 4, 5);
\end{minted}

La forma clásica de iterar sobre un arreglo es utilizando la construcción sintáctica \mintinline{js}{for}, como se muestra a continuación: 

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               linenos]{jsx}
let family = ["Jóse", "Nicolas", "Lucia", "Enrique"];
for (let element of family) {
  console.log("regular for: ", element);
}
\end{minted}
               
Sin embargo, los arreglos proveen de un conjunto de métodos muy convenientes y que utilizaremos con frecuencia. El más simple es \mintinline{js}{.forEach}:              
\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               linenos]{jsx}
let family = ["Jóse", "Nicolas", "Lucia", "Enrique"];

family.forEach(function (value, index, array) {
  //value es el elemento que se esta procesando
  //index es el índice del elemento que se esta procesando
  //array el arreglo completo
  console.log(value, index, array);
});
\end{minted}

\mintinline{js}{.forEach} acepta tres argumentos. \mintinline{js}{value} que es el elemento a procesar, \mintinline{js}{index} que es el índice que corresponde al valor que estamos procesando y \mintinline{js}{array} que es el arreglo que estamos iterando. Si solo nos interesa trabajar con \mintinline{js}{value}, podemos simplemente escribirlo así:

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               linenos]{jsx}
let family = ["Jóse", "Nicolas", "Lucia", "Enrique"];

family.forEach((value) => {
  //acá hacemos algo con value	
});
\end{minted}

Un método más interesante aún es \mintinline{js}{.filter}, el cual se utiliza para procesar el arreglo y devolver otro con igual o menos elementos. Recibe una función con los mismos parámetros que \mintinline{js}{.forEach} y devuelve un arreglo para aquellos elementos donde la función evalúa a true. Veamos cómo se utiliza a continuación:

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               linenos]{jsx}
let family = ["Jóse", "Nicolas", "Lucia", "Enrique"];

const members = family.filter((member) => {
  return member.length > 5;
});

//members = ['Nicolas', 'Enrique']
\end{minted}

\mintinline{js}{.filter} recibe una función que evalúa por cada elemento del arreglo si es mayor a 5. Aquellos elementos que sean mayores a 5 serán parte del nuevo arreglo que se retorna. El arreglo donde se aplica el filtro \textbf{no} es modificado.

Otro de los métodos interesantes, y principalmente útil para React como veremos más adelante, es \mintinline{js}{.map}. Éste método, al igual que el anterior, recibe una función (note que es una \textbf{arrow function}) como parámetro y retorna otro arreglo con el resultado de aplicar la función recibida sobre cada elemento. Veamos el siguiente ejemplo:

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               linenos]{jsx}
let numbers = [1, 2, 3, 4, 5, 6, 7];
const doubles = numbers.map((element) => {
  return element * 2;
});
//doubles = [2,  4,  6, 8, 10, 12, 14]
\end{minted}

Éstos métodos se pueden combinar. Veamos el siguiente ejemplo. Primero aplicamos \mintinline{js}{.filter} sobre un arreglo de enteros, para quedarnos solo con aquellos que son impares y luego multiplicamos por dos cada uno de los elementos para transformarlos en pares. 

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               linenos]{jsx}
let numbers = [1, 2, 3, 4, 5, 6, 7];
const chain = numbers
  .filter((element) => {
    return element % 2 !== 0;
  }) //[1, 3, 5, 7]
  .map((element) => {
    return element * 2;
  });
//chain = [2, 6, 10, 14]
\end{minted}

Existe una forma de asignar cada uno de los elementos de un arreglo a variables que se denomina \textbf{destructuring}. Veamos a continuación el siguiente ejemplo:

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               linenos]{jsx}
let [one, two, three] = [1, 2, 3];
//one = 1
//two = 2
//three = 3

//igual al ejemplo previo
let fewNumbers = [1, 2, 3];
[one, two, three] = fewNumbers;

//y acá ademas usando spread syntax
let [a, b, ...rest] = [1, 2, 3, 4, 5];
//a = 1
//b = 2
//rest = [3, 4, 5]
\end{minted}

\alertsuccess{Ejercicio: Escriba una \textbf{arrow function} que reciba un arreglo de strings por parámetro, y transforme el arreglo utilizando \textbf{map} invirtiendo cada uno de sus elementos. Es decir, si el arreglo de entrada es: ['abc123','456cde'], el resultado debería ser: ['321cba','edc654'].}

\section{Objetos}\label{jsobjects}

Existen varias formas de crear objetos en JavaScript. Aquí estudiaremos aquellas formas que utilizaremos con frecuencia programando en React. Comencemos estudiando como crear objetos con notación literal: \textbf{Object Literal}. Un objeto literal se crea encerrando entre llaves una colección de pares \textit{propiedad}:\textit{valor}, separadas por coma. Veamos el siguiente ejemplo: 

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               linenos]{jsx}
//object literal
let yo = {
  name: "Enrique",
  surname: "Molinari",
  sports: ["futbol", "tenis"],
  address: {
    street: "San Martin",
    number: 125,
  },
  allSports: function () {
    console.log(this.sports);
  },
};
//un objeto vacio
let obj = {};
\end{minted}

Como se puede ver del ejemplo anterior, en un objeto literal, los valores pueden ser arreglos (línea 5), funciones (línea 10) o incluso otros objetos (línea 6). Por otro lado, desde ES6, es posible crear objetos literales utilizando variables como nombre de propiedad. Veamos a continuación como se utiliza en la línea 6: 

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               highlightlines={6},
               linenos]{jsx}
let aproperty = "phone";               
//un objeto literal con una computed property name 
let computed = {
  name: "Enrique",
  surname: "Molinari",
  [aproperty]: "+54 2920 259031"
};

\end{minted}

Cada vez que el intérprete de JavaScript evalúa un objeto literal se crea la instancia. Las propiedades de los objetos se acceden utilizando la \textbf{notación de punto}. Veamos un ejemplo:

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               linenos]{jsx}
console.log(yo.name); //Enrique
console.log(yo.sports[0]);//futbol
console.log(yo.address.street);//San Martin
yo.allSports(); //invocando a la funcion               
\end{minted}

En JavaScript es posible agregar propiedades nuevas en tiempo de ejecución a los objetos. Éste concepto es sumamente importante para entender algunas cuestiones más adelante. Observen el siguiente ejemplo. En las línes 3 y 4, se agregan las propiedades \mintinline{js}{x} e \mintinline{js}{y} (inicializadas) al objeto \mintinline{js}{obj}.

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               linenos]{jsx}
let obj = {a: 1, b: 2};
//agrego nuevas propiedades al objeto
obj.x = 3;
obj.y = 4;
\end{minted}

Podemos utilizar la expresión denominada \textbf{spread syntax} con objetos también:

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               linenos]{jsx}
let obj1 = {
  a: 1,
  b: 2,
};
let obj2 = {
  c: 3,
  d: 4,
};
let obj3 = { ...obj1, ...obj2 };
//obj3 = { a: 1, b: 2, c: 3, d: 4 }
\end{minted}

Podemos crear objetos a partir de variables inicializadas, de la siguiente forma:

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               linenos]{jsx}
let a = 1,
  b = 2;
let obj4 = {
  a,
  b,
};
//obj4 = { a: 1, b: 2 }	
\end{minted}

Hasta el momento hemos visto cómo crear objetos utilizando la notación literal. Pero para aquellos que venimos estudiando lenguajes estáticos y compilados como Java, nos estaremos preguntando qué pasa si necesitamos una cantidad de instancias desconocidas, y con igual estructura, o sea, creadas a partir de una clase. Para esto, en JavaScript tenemos lo que denominamos \textbf{constructor functions}. También tenemos clases como veremos más adelante, pero las clases vienen mucho después, es importante primero entender cómo funciona una función constructora.
\newline

Por convención el nombre de una función constructora comienza con mayúscula. Veamos algunos ejemplos a continuación:

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               linenos]{jsx}
function Book(name, authors, publishedYear) {
  this.name = name;
  this.authors = authors;
  this.publishedYear = publishedYear;
  this.fullName = function () {
    return this.name + " by " + this.authors + ". " + publishedYear;
  };
}

thisBook = new Book("Coding in React", 
			["Enrique Molinari"], 2021);
thisBook.fullName(); //Coding in React by Enrique Molinari. 2021

archBook = new Book("Coding an Architecture Style", 
			["Enrique Molinari"], 2020);
archBook.fullName(); //Coding an Architecture Style by Enrique Molinari. 2020 
\end{minted}

Como podemos observar del ejemplo anterior, la función \mintinline{js}{Book} se parece mucho a un constructor de los que solemos tener cuando escribimos clases en lenguajes como Java. En las líneas 2, 3 y 4 definimos propiedades y las inicializamos con los parámetros recibidos. En la línea 5 definimos el método \mintinline{js}{fullName()}. Luego, en las líneas 10 y 14 creamos dos instancias de \mintinline{js}{Book} e invocamos al métodos \mintinline{js}{fullName()}. 

\alertsuccess{Ejercicio: Cree un objeto literal que modele los datos de una tarjeta de crédito e imprímalo en consola.}

\subsection{Un Lenguaje basado en Prototipos}

Ahora que sabemos como crear objetos con notación literal, como crear instancias a partir de funciones constructoras, podemos continuar explicando qué significa que JavaScript sea un lenguaje \textbf{basado en prototipos}. Los lenguajes basados en prototipos son un estilo de lenguajes orientados a objetos en los cuales los objetos son creados sin crear previamente una \textit{clase}. Por este motivo, éstos lenguajes también son conocidos como lenguajes \textit{classless} (sin clases). Por otro lado, lenguajes como Smalltalk, Java, C++ y C\#, para nombrar algunos, son conocidos como lenguajes \textit{class-based} (basados en clases).
\newline

En los lenguajes basados en prototipos, \textbf{no hay clases}, solo objetos. No existe esa diferencia entre clase y objeto. En lenguajes basados en clases, definimos una estructura estática con la posibilidad de definir entre ellas una relación de herencia, la cual no es posible modificar en tiempo de ejecución. En lenguajes basados en prototipos sólo tenemos instancias. No tenes clases, se hace evidente a medida vamos entendiendo cómo funciona JavaScript. Veamos algunos ejemplos.
\newline

Tal cual implementamos la función constructora \mintinline{js}{Book} en el ejemplo anterior, no es la forma ideal. Observemos por qué con el siguiente ejemplo:

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               linenos]{jsx}
thisBook = new Book("Coding in React", 
			["Enrique Molinari"], 2021);
archBook = new Book("Coding an Architecture Style", 
			["Enrique Molinari"], 2020);
//printing thisBook
//Book {
//  name: 'Coding in React',
//  authors: [ 'Enrique Molinari' ],
//  publishedYear: 2021,
//  fullName: [Function (anonymous)]
//}
//printing archBook
//Book {
//  name: 'Coding an Architecture Style',
//  authors: [ 'Enrique Molinari' ],
//  publishedYear: 2020,
//  fullName: [Function (anonymous)]
//}
\end{minted}

En el ejemplo anterior, creamos dos instancias: \mintinline{js}{thisBook} y \mintinline{js}{archBook}, y luego las imprimimos. Como podemos observar, cada una de las instancias no solo cuenta con sus propiedades y valores, sino que también tiene la propiedad \mintinline{js}{fullName}, con su código. Los fuentes de ese método no es almacenado en una clase y compartido por las instancias de dicha clase como en los lenguajes basados en clases. Si no que esta incluido en cada instancia. Éste es un detalle de implementación que tenemos que es importante entender, pero además devela una de las diferencias que podemos encontrar en lenguajes basados en prototipos.
\newline

¿Pero qué sucede con la \textit{herencia}? Al no tener clases, ¿tenemos herencia? La respuesta es Sí. La diferencia es que la relación de herencia en lenguajes basados en prototipos es dinámica, es decir que se puede establecer y cambiar en ejecución. Para entender cómo funciona la herencia en lenguajes sin clases, vamos a presentar el concepto de \textbf{prototype}. 
\newline

Cada objeto en JavaScript (y en general en cualquier lenguaje basado en prototipos) puede estar asociado a lo que se denomina un \textbf{objeto prototipo}, del cual hereda todas sus propiedades y métodos. Si sobre una instancia queremos acceder a una propiedad y ésta no está definida allí, se \textbf{delega} su búsqueda en el objeto prototipo asociado. Como los prototipos pueden tener también un prototipo, se delegará en ellos hasta que se encuentre la propiedad o termina la ejecución con error al no encontrarla. Ésto se conoce como \textbf{prototype chain}.
\newline

Las funciones constructoras tienen acceso a una propiedad especial denominada \mintinline{js}{prototype} y la podemos acceder de la siguiente forma: \mintinline{js}{Book.prototype}. Con una instancia de un objeto es posible acceder a esta propiedad de la siguiente forma: \mintinline{js}{thisBook.__proto__} o lo que es lo mismo: \mintinline{js}{Object.getPrototypeOf(thisBook)}. 
\newline

Sabiendo esto, entonces si queremos mejorar la función constructora \mintinline{js}{Book} de modo de que cada instancia no cuente con los métodos que se definen, la creamos de la siguiente forma:

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               linenos]{jsx}
function Book(name, authors, publishedYear) {
  this.name = name;
  this.authors = authors;
  this.publishedYear = publishedYear;
}
Book.prototype.fullName = function () {
  return this.name + " by " + this.authors + ". " + this.publishedYear;
};               
               
thisBook = new Book("Coding in React", 
			["Enrique Molinari"], 2021);
archBook = new Book("Coding an Architecture Style", 
			["Enrique Molinari"], 2020);
//printing thisBook
//Book {
//  name: 'Coding in React',
//  authors: [ 'Enrique Molinari' ],
//  publishedYear: 2021
//}
//printing archBook
//Book {
//  name: 'Coding an Architecture Style',
//  authors: [ 'Enrique Molinari' ],
//  publishedYear: 2020
//}
\end{minted}

En el ejemplo anterior, definimos el método \mintinline{js}{fullName()} en el prototipo, en la línea 6. Luego creamos dos instancias y las imprimimos. Ahora podemos ver que el método \mintinline{js}{fullName()} no está en éstas instancias. Sin embargo, si lo invocamos así:

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               linenos]{jsx}

thisBook.fullName();
\end{minted}

JavaScript buscará primero el método en la instancia \mintinline{js}{thisBook}. Al no encontrarlo, irá por su prototipo y la ejecutará.
\newline

Toda cadena de prototipos finaliza en \mintinline{js}{Object.prototype}, dado que todo objeto en JavaScript es descendiente de \href{https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Object}{Object}. Con lo cual, si ejecutamos la siguiente invocación:

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               linenos]{jsx}

thisBook.valueOf();
\end{minted}

JavaScript recorrerá la cadena de prototipos hasta encontrar el método \mintinline{js}{valueOf()} en \mintinline{js}{Object.prototype}. Creemos ahora un ejemplo utilizando herencia. Crearemos el objeto \mintinline{js}{EBook} que hereda de \mintinline{js}{Book}, como se muestra a continuación.

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               breaklines=true,
               linenos]{jsx}

function EBook(filesize, name, authors, publishedYear) {
  Book.call(this, name, authors, publishedYear);
  this.filesize = filesize;
}
let eBook = new EBook(2048, "Coding in React", ["Enrique Molinari"], 2021);

//printing eBook:
//eBook:  EBook {
//  name: 'Coding in React',
//  authors: [ 'Enrique Molinari' ],
//  publishedYear: 2021,
//  filesize: 2048
//}
\end{minted}

En el ejemplo anterior creamos la función constructora \mintinline{js}{EBook}. En la línea 2, invocamos a la función constructora \mintinline{js}{Book} y para ello utilizamos el método \mintinline{js}{call} (\href{https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Function/call}{Function.prototype.call}) que permite invocar una función pasándole como parámetro el valor que utilizará para \mintinline{js}{this}. En éste caso observen que le pasamos aquella instancia de \mintinline{js}{EBook} que se crea vía el operador \mintinline{js}{new}, en la línea 5. Esto que estamos haciendo es similar a utilizar \mintinline{js}{super(...)} dentro de un constructor de una clase, para instanciar e inicializar la superclase. 
\newline

En la línea 5, como mencionamos, creamos una instancia de \mintinline{js}{EBook} e imprimimos la instancia. Vemos como resultado de la impresión que contamos con las propiedades de \mintinline{js}{Book} también. Sin embargo, no tenemos el método \mintinline{js}{fullName()} definido en \mintinline{js}{Book.prototype}. Para heredarlo necesitamos setear como prototipo a \mintinline{js}{Book.prototype}. Lo hacemos de la siguiente manera:

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               linenos]{jsx}

Object.setPrototypeOf(eBook, Book.prototype);

//Otra forma de hacer lo mismo de arriba:
//thisEBook.__proto__ = Book.prototype;
//Ojo que  __proto__ esta deprecado
\end{minted}

\mintinline{js}{Object.setPrototypeOf} recibe dos parámetros, el primero es la instancia a la cual le asigno un prototipo y el segundo parámetro es el prototipo a asignar.

\section{Clases}

Sí! JavaScript tiene clases y su sintaxis es muy similar a la que conocemos de lenguajes basados en clases como Java. Las clases en JavaScript fueron incorporadas al lenguaje en 2015 como parte de EcmaScript 6 (ES6). Lo que es importante entender, es que ésto no transforma a JavaScript en un lenguaje basado en clases. Las clases son solo una \textbf{mejora sintáctica} (syntactic sugar) para poder utilizar herencia sin lídear con lo que mostramos en la sección anterior. Por detrás siempre son funciones constructoras y herencia basada en prototipos.
\newline

Implementemos entonces la jerarquía \mintinline{js}{Book} e \mintinline{js}{EBook} de la sección anterior pero ahora utilizando clases:

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               breaklines=true,               
               linenos]{jsx}

class Book {
  constructor(name, authors, publishedYear) {
    this.name = name;
    this.authors = authors;
    this.publishedYear = publishedYear;
  }

  //este método se agrega a Book.prototype
  fullName() {
    return this.name + " by " + this.authors + ". " + this.publishedYear;
  }
}

class EBook extends Book {
  constructor(filesize, name, authors, publishedYear) {
    super(name, authors, publishedYear);
    this.filesize = filesize;
  }
}
\end{minted}

En el ejemplo anterior construimos la relación de herencia entre \mintinline{js}{EBook} y \mintinline{js}{Book}, utilizando clases. Pero en ejecución termina quedando exactamente lo mismo que utilizando funciones constructoras como lo hicimos en la sección anterior. Veamos el siguiente ejemplo que lo demuestra:

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               breaklines=true,               
               linenos]{jsx}

let ebook = new EBook(2048, "Coding in React", ["Enrique, Molinari"], 2021);
//Book.prototype es el prototype de la instancia ebook
console.log(Book.prototype.isPrototypeOf(ebook)); //true
//el método fullName esta en prototype
console.log(ebook.fullName()); //Coding in React by Enrique, Molinari. 2021
//EBook es una función, no una clase
console.log(typeof EBook); //function
\end{minted}

Primero hemos creado una instancia de \mintinline{js}{EBook} y luego en la línea 3 verificamos que \mintinline{js}{Book.prototype} está seteado como el prototipo de la instancia \mintinline{js}{ebook}. De esta forma comprobamos que tenemos en ejecución la relación de herencia basada en prototipos como construimos en la sección anterior.

\section{¿Cómo se comporta el \textit{this} en JavaScript?} \label{meaning_of_this}

En las secciones anteriores hemos estado utilizando \mintinline{js}{this} en aquellas situaciones en las que tu comportamiento es el mismo que en lenguajes basados en clases como Java o C\#. Sin embargo, hay ciertas diferencias para algunas construcciones sintácticas que necesitamos entender para poder luego entender el porqué de algunas cuestiones que necesitamos hacer en React.
\newline

Si utilizamos \mintinline{js}{this} en funciones constructoras y creamos las instancias utilizando \mintinline{js}{new}, \mintinline{js}{this} apuntará a la instancia creada. Sin embargo, si la función constructora es invocada (como lo haríamos con cualquier función), \mintinline{js}{this} tendrá otro valor. Veamos el siguiente ejemplo:

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               breaklines=true,               
               linenos]{jsx}
function Constr(param) {
  this.param = param;
}

Constr(2); //this apunta al objeto global window
console.log(window.param); //imprime 2
\end{minted}

Invocando a la función \mintinline{js}{Const} tal como lo hacemos en la línea 5 tiene un efecto bastante extraño. En estos casos, \mintinline{js}{this} apunta al objeto global \mintinline{js}{window}. Con lo cual, lo que termina haciendo éste ejemplo es agregando la propiedad \mintinline{js}{param} al objeto \mintinline{js}{window} con el valor 2.
\newline

El ejemplo anterior no es algo que vayamos a utilizar con frecuencia en React, sin embargo son cuestiones a tener presentes. Otra forma donde el \mintinline{js}{this} pierde valor es cuando asignamos un método a una variable, y ésto sí es importante entender si queremos usar clases en React. Veamos el siguiente ejemplo:

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               breaklines=true,               
               linenos]{jsx}
class Person {
  constructor(name) {
    this.name = name;
  }
  saySomething() {
    console.log(this.name + " is talking...");
  }
}
let enrique = new Person("Enrique");
enrique.saySomething(); //Enrique is talking...

let o = enrique.saySomething; //asignamos el método a una variable
o(); //TypeError: Cannot read property 'name' of undefined
\end{minted}

En el ejemplo anterior creamos en la línea 9 una instancia de la clase \mintinline{js}{Person} y luego en la línea 10 invocamos al método \mintinline{js}{saySomething()}. Hasta acá todo perfecto, el \mintinline{js}{this} en la línea 6 funciona funciona tal como esperamos. Sin embargo, en la línea 12 asignamos el método a una variable y en la siguiente línea utilizamos dicha variable para invocar al método. En esta ocasión, \mintinline{js}{this} es \mintinline{js}{undefined}, provocando un error. Para arreglar este comportamiento, necesitamos, en forma explicita, decirle al método qué valor de \mintinline{js}{this} queremos que utilice, algo similar a lo que hicimos con el método \mintinline{js}{call} en secciones anteriores. Veamos cómo lo resolvemos con el siguiente ejemplo:
 
\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               breaklines=true,
               highlightlines={4},               
               linenos]{jsx}

class Person {
  constructor(name) {
    this.name = name;
    this.saySomething = this.saySomething.bind(this);    
  }
  saySomething() {
    console.log(this.name + " is talking...");
  }
}
let enrique = new Person("Enrique");
enrique.saySomething(); //Enrique is talking...

let o = enrique.saySomething; 
o(); //Enrique is talking...
\end{minted}

El método \href{https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Function/bind}{bind} que utilizamos en la línea 4, devuelve la misma función pero con el valor de \mintinline{js}{this} seteado con el parámetro recibido. En este caso, le pasamos \mintinline{js}{this}, el cual apuntará a la instancia creada. De ésta forma al invocar nuevamente utilizando \mintinline{js}{o()}, funcionará de la forma esperada.
\newline

Otra forma de solucionar este mismo inconveniente es declarando el método dentro de la clase utilizando funciones flecha (arrow functions). Veamos el siguiente ejemplo:

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               breaklines=true,
               highlightlines={5},               
               linenos]{jsx}

class Person {
  constructor(name) {
    this.name = name;
  }
  saySomething = () =>  {
    console.log(this.name + " is talking...");
  }
}
let enrique = new Person("Enrique");
enrique.saySomething(); //Enrique is talking...

let o = enrique.saySomething;
o(); //Enrique is talking...
\end{minted}

Definiendo el método \mintinline{js}{saySomething} de esta forma no tendremos el inconveniente que mostramos antes. Las funciones flecha le asignan al \mintinline{js}{this} el valor que tenga en el ámbito léxico en el que se crean. El cual en este caso es la clase. Sin embargo, lo métodos definidos de esta forma no son agregados al prototipo del objeto sino que son parte del objeto, provocando lo que ya hemos mencionado que cada nueva instancia tendrá una copia del código del método.

\section{Módulos}

En ECMAScript 2015 (ES6) incorporaron al lenguaje la posibilidad de definir módulos. En las versiones anteriores de JavaScript si queríamos definir módulos teníamos que utilizar alguna herramienta externa como requirejs \cite{requirejs}. Ahora está soportado de forma nativa. 
\newline

Realmente es muy simple de utilizar. En un archivo JavaScript podemos definir funciones, clases, objetos, constantes, variables, etc y exportar solo aquellos que queremos que sean visibles para los clientes del módulo. Para exportar utilizamos la palabra reservada \mintinline{js}{export}. Los clientes del módulo deben importar explícitamente aquello que quieran utilizar. Importan utilizando la palabra reservada \mintinline{js}{import}. Veamos algunos ejemplos:
 
\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               breaklines=true,
               linenos]{jsx}
//mi modulo complex-module.js

export function complexThing() {
  console.log("ejecutando algo complejo...");
}

export let obj = {
  a: 1,
  b: 2,
};

export class ASimpleClass {
  constructor(name) {
    this.name = name;
  }

  print() {
    console.log("printing: ", this.name);
  }
}
\end{minted}

En el módulo \textit{complex-module.js} del ejemplo anterior exportamos una función, un objeto y una clase. También es posible realizar lo mismo de la siguiente forma:

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               breaklines=true,
               highlightlines={22},               
               linenos]{jsx}
//mi modulo complex-module.js

function complexThing() {
  console.log("ejecutando algo complejo...");
}

let obj = {
  a: 1,
  b: 2,
};

class ASimpleClass {
  constructor(name) {
    this.name = name;
  }

  print() {
    console.log("printing: ", this.name);
  }
}

export { obj, ASimpleClass, complexThing };
\end{minted}

Por supuesto, en un módulo solo debemos exportar aquello que queremos exponer hacia afuera del módulo y no todo como en este caso hemos hecho. 	
\newline

Veamos ahora cómo podemos utilizar y consumir lo exportado por un módulo.

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               breaklines=true,
               highlightlines={22},               
               linenos]{jsx}
//este es el módulo main-module.js

import { complexThing, obj, ASimpleClass } from "./module/complex-module.mjs";

//invocando a la función importada
complexThing();

//imprimimos el objeto que importamos
console.log(obj);

//creamos una instancia de la clase importada
let o = new ASimpleClass("Enrique");
o.print();
\end{minted}

En la línea 3 importamos las tres abstracciones que \textit{complex-module.js} exporta. Y simplemente las utilizamos como si estuvieran definidas allí mismo. Es posible definir una abstracción a exportar por defecto. Observen en el siguiente ejemplo cómo exportamos las mismas abstracciones pero la clase la exportamos utilizando las palabras reservadas \textit{export default}:

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               breaklines=true,
               highlightlines={22},               
               linenos]{jsx}
//este es el módulo complex-module.js

function complexThing() {
  console.log("ejecutando algo complejo...");
}

let obj = {
  a: 1,
  b: 2,
};

class ASimpleClass {
  constructor(name) {
    this.name = name;
  }

  print() {
    console.log("printing: ", this.name);
  }
}

export default ASimpleClass;
export { obj, complexThing };
\end{minted}

Esto nos permite, como vemos en el siguiente ejemplo en la línea 3, importar la clase pero con un nombre diferente al que se definió en el módulo donde reside.

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               breaklines=true,
               highlightlines={3},               
               linenos]{jsx}
//este es el módulo main-module.js

import AClass from "./module/complex-module.mjs";
//lo mismo que:
//import { default as AClass } from "./module/complex-module.mjs";
import { obj, complexThing } from "./module/complex-module.mjs";

let o = new AClass("Enrique");
o.print();

//... más lineas de código aca 
\end{minted}

\alertsuccess{Ejercicio: Cree un módulo servicio.mjs (los módulos en nodejs requieren de la extensión \textit{.mjs}) y exponga la función creada anteriormente para invertir los elementos de un arreglo. Luego importe dicha función desde un archivo cliente.mjs e invóquela.}

\section{Llamadas Ajax usando fetch}

A partir de la versión ES6 podemos realizar peticiones Ajax utilizando el método \href{https://developer.mozilla.org/es/docs/Web/API/WindowOrWorkerGlobalScope/fetch}{fetch}. La firma de éste método es la siguiente:

\begin{itemize}
 \item \mintinline{jsx}{Promise<Response> fetch(url [, init])} 
\end{itemize}

\href{https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Promise}{Promise} es un objeto que representa un valor que puede estar disponible ahora, en el futuro o nunca. Es el resultado de una operación asíncrona. Luego volveremos sobre Promise. Como parámetros el método fetch recibe la URL a la cual invocará y de forma opcional un objeto para configurar el tipo de petición que se realizará. Por ejemplo, la forma más simple de utilizar fetch es la siguiente:

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               breaklines=true,
               linenos]{jsx}
fetch("https://jsonplaceholder.typicode.com/posts/1")
  .then((response) => response.json())
  .then((json) => console.log(json))
  .catch((error) => console.log(error));
\end{minted}

Observen que solo utilizamos el primer parámetro que es el único obligatorio. Ésta es una petición HTTP de tipo \href{https://developer.mozilla.org/es/docs/Web/HTTP/Methods/GET}{GET} que retorna de un servicio de blog ficticio el post con identificador 1. Las peticiones HTTP de tipo GET solo deben utilizarse para recuperar datos, \textbf{nunca} para realizar alguna inserción o modificación. Son peticiones \textbf{idempotentes}, es decir que el efecto que provoca en el servicio que consume es el mismo ya sea enviando una única petición o múltiples.
\newline

La función fetch retorna un objeto Promise, el cual expone dos métodos que utilizaremos mucho: \mintinline{jsx}{then(funcion(response))} y \mintinline{jsx}{catch(funcion(error))}. \mintinline{jsx}{then(funcion(response))} se llama si hubo una respuesta exitosa por parte del servicio que estamos consumiendo y como parámetros tenemos la respuesta. Entonces con la respuesta en la línea 2 la transformamos a un JSON y luego en la línea 3 lo imprimimos en la consola. Finalmente el método \mintinline{jsx}{catch(funcion(error))} es invocado si hubiera algún error con la respuesta obtenida o en su defecto si no es posible obtener respuesta alguna.
\newline

Veamos ahora cómo podemos utilizar el parámetro opcional del método fetch para realizar una petición de tipo \href{https://developer.mozilla.org/es/docs/Web/HTTP/Methods/POST}{POST}. El método POST no es idempotente, llamarlo varias veces tendrá efectos adicionales sobre el servicio invocado. Veamos un ejemplo:

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               breaklines=true,
               linenos]{jsx}
fetch("https://jsonplaceholder.typicode.com/posts/", {
 method: "POST",
 headers: {
  "Content-type": "application/json; charset=UTF-8",
 },
 body: JSON.stringify({
  name: "Enrique",
  userName: "emolinari",
  email: "emolinari@unrn.edu.ar",
 }),
})
 .then((response) => response.json())
 .then((json) => console.log(json));
\end{minted}

Observemos que como segundo parámetro del método fetch estamos pasando un objeto literal con las siguiente propiedades:

\begin{itemize}
 \item \mintinline{jsx}{method:} Aquí especifico que es un request de tipo POST. 
 \item \mintinline{jsx}{headers:} Aquí le aviso al servicio al cual estoy invocando que los datos enviados como valor de la propiedad \mintinline{jsx}{body} tienen una estructura JSON. 
 \item \mintinline{jsx}{body:} Aquí van los datos a enviar. Observen que se utiliza el método \mintinline{jsx}{JSON.stringify} transformando un objeto literal en un JSON. 
\end{itemize}

\section{Async y Await Keywords}

Veamos otra forma que nos da JavaScript de trabajar con las Promises. Como mencionamos en la sección anterior, para obtener el resultado de una llamada utilizando \mintinline{js}{fetch}  tenemos que manejar el objeto \textbf{Promise}, veamos el siguiente ejemplo:

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               breaklines=true,
               linenos]{jsx}
function fetchBlogPosts() {
 fetch("https://jsonplaceholder.typicode.com/posts/1")
  .then((response) => response.json())
  .then((json) => console.log(json));
}

fetchBlogPosts();
\end{minted}

Como se puede ver en la línea 2 anterior, el método \mintinline{js}{fetch} devuelve una promesa, lo que nos permite llamar al método \mintinline{js}{then} en él para trabajar con los datos de la respuesta.
\newline

Otra forma de manejar las promesas es mediante el uso de las keywords \mintinline{js}{async} y \mintinline{js}{await}. Estas palabras clave se agregaron a JavaScript en ES2017, lo que nos permite escribir código asíncrono de manera síncrona. Vamos a reescribir el ejemplo anterior para aprovechar estas palabras clave:

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               breaklines=true,
               linenos]{jsx}
async function fetchPost() {
  let data = await fetch("https://jsonplaceholder.typicode.com/posts/1");
  data = await data.json();
  console.log(data);
}

fetchPost();
\end{minted}

Como se puede ver, es necesario declarar la función con la palabra clave \mintinline{js}{async} (línea 1) y la llamada a \mintinline{js}{fetch} en la línea 2 se antepone con la palabra clave \mintinline{js}{await}. Anteponer la palabra clave \mintinline{js}{await} a la función \mintinline{js}{fetch} significa que, en lugar de devolver un objeto \href{https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Promise}{Promise}, devuelve un objeto \href{https://developer.mozilla.org/es/docs/Web/API/Response}{Response}. Esto nos permite llamar directamente en la línea 3 al método \mintinline{js}{json()} del objeto \href{https://developer.mozilla.org/es/docs/Web/API/Response}{Response}. Como ese método devuelve una promesa, también anteponemos la sentencia con la palabra clave \mintinline{js}{await}, lo que nos da un objeto JavaScript que finalmente se imprime en la consola.
\newline

Es importante tener en cuenta que la palabra clave \mintinline{js}{await} solo se puede utilizar dentro de una función \mintinline{js}{async}.

\section{Lenguaje Single Thread} \label{single_thread}

Dijimos que JavaScript es un lenguaje single threaded. Es decir, siempre existe un único hilo de ejecución (con una única pila de ejecución y un heap) que interpreta y ejecuta una sentencia a la vez. La siguiente sentencia no comienza a ejecutarse hasta que la anterior no termina. Esto podría ser muy perjudicial sobre todo con operaciones que lleven algo de tiempo. Por ejemplo, en una petición Ajax mientras esperamos tener una respuesta de algún servicio remoto no podríamos interactuar con alguna otra parte del sitio web. Ésto es así cuando utilizamos el método \mintinline{js}{window.alert}. Hasta no apretar el botón Aceptar no es posible hacer nada más.
\newline

Por éste motivo es que existen en JavaScript operaciones \textit{asincrónicas} como las llamadas Ajax que vimos en la sección anterior. Entonces, ¿cómo es que funciona?
\newline

El intérprete de JavaScript recibe ayuda del Browser para ésto. Existen ciertas operaciones que el intérprete de JavaScript reconoce y en lugar de ejecutarlas él mismo, las \textit{delega} en el Browser, quien las ejecuta en su hilo para lugar devolverlas al intérprete como \textit{callbacks}. Entre éstas operaciones encontramos los eventos (onclick, onmouseover, etc), la función Fetch o XMLHttpRequest (ajax calls), setTimeout, etc. Para lograr ésto el ambiente de ejecución de JavaScript utiliza una \textit{pila de llamadas}, el Browser, una \textit{cola de callbacks} y el \textit{loop de eventos}. Observemos el siguiente ejemplo para entender cómo es su ejecución dentro de éste ambiente:

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               breaklines=true,
               linenos]{jsx}
console.log("starting");

setTimeout(() => {
  console.log("callback");
}, 1000);

console.log("finishing");
\end{minted}

Veamos entonces como JavaScript resuelve la ejecución de éste programa:
\begin{enumerate}
\item La setencia de la línea 1 se inserta en la \textit{pila de llamadas} y es ejecutada. Se imprime en la consola \mintinline{js}{"starting"}. 
\item La función \mintinline{js}{setTimeout} de la línea 3 se delega al Browser para que éste la ejecute. Y se continúa con la ejecución de la siguiente sentencia.
\item La sentencia de la línea 7 se inserta en la \textit{pila de llamadas} y es ejecutada. Se imprime en la consola \mintinline{js}{"finishing"}.
\item En el Browser, la ejecución de \mintinline{js}{setTimeout} hace que se deba esperar un segundo. Cuando se termina, la función que recibe por parámetro \mintinline{js}{setTimeout}, se inserta en la \textit{cola de callbacks}. Dado que no existen en el programa otras sentencias a ejecutar, el \textit{loop de eventos} comienza a ejecutar aquello que se encuentra en el \textit{cola de callbacks}. Toma la primera y la inserta en la \textit{pila de llamadas} para luego ser ejecutada imprimiendo \mintinline{js}{"callback"} en la consola.
\end{enumerate}

Es importante entender que todas las funciones callback que se insertan en la \textit{callback queue} son ejecutadas luego de que no hay más sentencias para ejecutar en el programa. Veamos un ejemplo más:

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               breaklines=true,
               highlightlines={5},                              
               linenos]{jsx}
console.log("starting");

setTimeout(() => {
  console.log("callback");
}, 0);

console.log("finishing");
\end{minted}

En el ejemplo anterior estamos pasando \mintinline{js}{0} segundos a \mintinline{js}{setTimeout}, y de igual forma el orden en el que se imprimen los mensajes en consola sigue siendo el mismo que en el ejemplo anterior: \mintinline{js}{"starting"}, \mintinline{js}{"finishing"}, \mintinline{js}{"callback"}. Esto es así porque los pasos de ejecución siguen siendo los mismos. \mintinline{js}{setTimeout} se envía al Browser, quien agrega a la \textit{cola de callbacks} la función que recibe por parámetro para ser tomada y ejecutada solo después de la última sentencia del programa.
\newline

El mismo comportamiento sucede con llamadas Ajax, veamos el siguiente ejemplo:

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               breaklines=true,
               linenos]{jsx}
console.log("starting");
fetch("https://jsonplaceholder.typicode.com/posts/1")
  .then((response) => response.json())
  .then((json) => console.log(json));
console.log("finishing");
\end{minted}

La ejecución de \mintinline{js}{fetch} se delega en el Browser y sigue la ejecución del programa. Cuando el Browser recibe respuesta del servicio externo al que esta invocando, inserta las dos funciones en la \textit{cola de callbacks}. Éstas son ejecutadas luego de imprimir \mintinline{js}{"finishing"} en la consola.
\newline

Recomiendo escuchar la charla de Philip Roberts\cite{loupe} para más detalles de cómo funciona el intérprete de JavaScript.


\begin{thebibliography}{100} % 100 is a random guess of the total number of
%references
\bibitem{mozilla} \url{https://developer.mozilla.org/en-US/docs/Web/JavaScript}
\bibitem{ecma} \url{https://www.ecma-international.org/}
\bibitem{node} \url{https://nodejs.org/}
\bibitem{requirejs} \url{https://requirejs.org/}
\bibitem{loupe} \url{http://latentflip.com/loupe/}
\end{thebibliography}


\end{document}
%token 1c5334cb5d68999c16e3dda57848c4dccbe61c83
