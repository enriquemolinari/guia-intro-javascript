\documentclass[a4paper, oneside, titlepage, 12pt]{book}
\usepackage[spanish]{babel}
\usepackage{floatrow}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{minted}
\usepackage{amsmath}
\usepackage{calc}
\usepackage{dirtree}
\usepackage{graphicx}
\usepackage[colorlinks = true,
            linkcolor = blue,
            urlcolor  = blue,
            citecolor = blue,
            anchorcolor = blue]{hyperref}
\usepackage{csquotes}
\usepackage{svg}
%esto es para que las imagenes no se vayan fuera de la seccion donde estan
\usepackage[section]{placeins} 
\usepackage{forest}
\usepackage{adjustbox}
\graphicspath{ {./yed/} }
\svgpath{{svg/}{./yed/}}
\apptocmd{\dirtree}{\bigskip}{}{}
\pretocmd{\dirtree}{\bigskip}{}{}

\newcommand{\changeurlcolor}[1]{\hypersetup{urlcolor=#1}} 
\newcommand{\explain}[2]{\underbrace{#1}_{\parbox{\widthof{#1}}{\footnotesize\raggedright #2}}}

\floatsetup[listing]{style=Plaintop}   
%\usemintedstyle{react}
\usemintedstyle{enrique}
%\usemintedstyle{tango}
\definecolor{bg}{HTML}{282b35}
\definecolor{verylight}{RGB}{237, 236, 236}

\lstset{
basicstyle=\small, % print whole listing small
keywordstyle=\color{black}\bfseries\underbar,
identifierstyle=, % nothing happens
commentstyle=\color{white}, % white comments
stringstyle=\ttfamily, % typewriter type for strings
showstringspaces=false} % no special string spaces

 
%Esto es para que no le ponga un recuadro
%rojo a los links de la TOC
\hypersetup{%
    pdfborder = {0 0 0}
}

\title{%
	Guía sobre \textsc{React}\\
	\large Comenzando a Programar Interfaces Web con React}
%\author{\textit{Author}\\Enrique Pablo Molinari}
\date{\today}

\begin{document}

\maketitle
\tableofcontents

\chapter*{Entorno de Desarrollo}
\addcontentsline{toc}{chapter}{Entorno de Desarrollo}

Para comenzar a programar en React recomendamos \href{https://code.visualstudio.com/} {Visual Studio Code} (VS Code). Y para ser más productivo, especialmente si eres nuevo en React, sugerimos que instales la extensión \href {https://marketplace.visualstudio.com/items?itemName=dsznajder.es7-react-js-snippets} {VS Code ES7 React / Redux / React-Native / JS snippets} que proporciona la generación rápida de estructuras sintácticas de JavaScript y React. También sugerímos instalar \href {https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode} {Prettier}, que es un formateador de código JavaScript / React.
\newline

Para instalar una extensión, en Visual Studio Code, vaya al menú Archivo, luego Preferencias y luego Extensiones. Verá un cuadro de búsqueda que le permitirá encontrar las extensiones que desea instalar.
\newline

Finalmente, realmente recomiendo configurar VS Code para formatear los fuentes al momento de guardar. Puede hacerlo yendo al menú Archivo, luego a Preferencias y luego a Configuración. En el cuadro de búsqueda, escriba "Editor: Formato al guardar" (Format On Save). Esto formateará su código inmediatamente después de guardarlo.

\part{Introducción}
		
\chapter{Conceptos Esenciales de JavaScript}

Si deseamos dominar React y eso significa comprender por qué y cómo funcionan ciertas cosas, debemos aprender algunos conceptos específicos de JavaScript.
\newline

En este capítulo explicaremos los conceptos de JavaScript y las construcciones sintácticas necesarias para crear un camino sólido que nos permitan dominar React. Si desea profundizar en más detalles sobre algunos de los temas que se explican aquí u otros sobre JavaScript, recomendamos que visiten el sitio web Mozilla \cite{mozilla}. Esta sección se basa en conceptos explicados allí. Habiendo dicho eso, comencemos. 

De la web Developer Mozilla JavaScript Documentation \cite{mozilla}, JavaScript se define como:

``JavaScript (JS) es un lenguaje de programación ligero, interpretado, o compilado justo-a-tiempo (just-in-time) con funciones de primera clase. Si bien es más conocido como un lenguaje de scripting (secuencias de comandos) para páginas web, y es usado en muchos entornos fuera del navegador, tal como Node.js, Apache CouchDB y Adobe Acrobat. JavaScript es un lenguaje de programación basada en prototipos, multiparadigma, de un solo hilo, dinámico, con soporte para programación orientada a objetos, imperativa y declarativa (por ejemplo programación funcional).''
\newline

Si Usted es un desarrollador Java, C\# o C++, esta definición puede sonar un poco intimidante. Es por ésto que es necesario aprender algunos conceptos, especialmente aquellos que no están disponibles de forma natural en los lenguajes compilados. Para comenzar con esos conceptos, primero explicaremos las construcciones básicas del lenguaje, luego explicaremos lo que significa que un lenguaje tenga \textbf{funciones de primera clase} y sea \textbf {basado en prototipos}, \textbf{multi-paradigma}, \textbf{de un solo subproceso} y \textbf{dinámico}.
\newline

El lenguaje JavaScript se rige por una especificación estándar de ECMA\cite{ecma} (European Computer Manufacturers Association). ECMAScript es el nombre de la especificación. En particular, en 2015 se liberó una versión importante conocida como ES6, ECMAScript 6 o ECMAScript 2015. La mayoría de las construcciones sintácticas que estudiaremos en esta sección se implementaron en dicha versión.
\newline

Comencemos a aprender. Toda sentencia en JavaScript escrita en esta sección se ejecutará usando el intérprete de nodejs, invocándolo usando la consola de la siguiente manera:
\begin{minted}[fontseries=mc,
               framesep=2mm]{console}
$ node yourjsfile.js
\end{minted}

Utilizando Visual Studio Code, pueden abrir una consola directamente allí, desde el menu en "Terminal" y luego "Nueva Terminal". 
\newline

Lo primero que en general aprendemos cuando nos iniciamos en un lenguaje de programación es a imprimir texto en la pantalla. Esta guía no es la excepción. Se puede imprimir texto en la pantalla usando el objeto \textit{Console} de la siguiente forma:

\begin{minted}[fontseries=mc,
               framesep=2mm,
               frame=leftline,
               linenos,
               framerule=0.1pt]{jsx}
console.log("Coding in React!");
\end{minted}

El objecto \textit{Console} se creó principalmente como herramienta de debug, no debe utilizarse en aplicaciones deployadas en producción. No es parte parte del estándar pero todos los browsers modernos y nodejs lo soportan.
\newline

\section{Variables}

Comencemos a ver como utilizamos \textbf{variables} en JavaScript. Declaramos las variables utilizando la palabra reservada \textit{let}, de la siguiente forma:

\begin{minted}[fontseries=mc,
               frame=leftline,
               linenos,
               framerule=0.1pt,
               framesep=2mm]{jsx}
let myFirstVariable;
\end{minted}

Cuando declaramos una variable sin inicializarla, el intérprete la inicializará con el valor especial \textit{undefined}. Esto se puede observar si intentan imprimir en la consola una variable no inicializada. Pruebenlo. El siguiente ejemplo muestra como declarar una variable y como inicializarla a la vez.

\begin{minted}[fontseries=mc,
               framesep=2mm,
               frame=leftline,
               linenos,
               framerule=0.1pt]{jsx}
let myFirstVariable = "Hello value!";
\end{minted}

Tambén es posible declarar una variable utilizando la palabra reservada \textit{const}:

\begin{minted}[fontseries=mc,
               framesep=2mm,
               frame=leftline,
               linenos,
               framerule=0.1pt]{jsx}
const myFirstConst = "Hello constant value!";
\end{minted}

Al declarar la variable con \textit{const} no podremos modificarle su valor, si lo intentan el interprete lanzará un error. Pruebenlo.  
\newline

Dijimos que JavaScript es un \textbf{lenguaje dinámico}. Ésto, entre otras cosas, significa que el tipo de una variable puede cambiar en tiempo de ejecución. A diferencia de los lenguajes estáticos donde los tipos de las variables se definen durante la compilación y no pueden cambiar durante la ejecución.

\begin{minted}[fontseries=mc,
               framesep=2mm,
               frame=leftline,
               linenos,
               framerule=0.1pt]{jsx}
//my type is string
let changeMyType = "Hello String!";
//now it is number
changeMyType = 100;
\end{minted}

\section{Funciones} \label{functions}

Estudiemos ahora las \textbf{functions}. A continuación declaramos una función y luego la invocamos:

\begin{minted}[fontseries=mc,
               framesep=2mm,
               frame=leftline,
               linenos,
               framerule=0.1pt]{jsx}
function saySomething(string) {
  console.log(string);
}

saySomething("Hello Function!");
\end{minted}

En JavaScript podemos definir funciones que se invocan inmediatamente después de declararlas. Se denominan IIFE (Immediately-invoked Function Expression).

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               linenos,
               framerule=0.1pt]{jsx}
(function saySomething(string) {
  console.log(string);
})("Hello Function!");
\end{minted}

Las funciones siempre retornan un valor. Si se omite el uso de \textit{return} para retornar algo explícito, entonces una función retornará el valor \textit{undefined}.

\begin{minted}[fontseries=mc,
               framesep=2mm,
               frame=leftline,
               linenos,
               framerule=0.1pt]{jsx}
let x = saySomething("Hello Function!");
//x is undefined
\end{minted}

También hemos mencionado que las funciones son objetos de \textbf{primera clase}. Ésto significa que al igual que las variables, éstas pueden asignarse, pasarse por parámetro o retornarse de otra función. El ejemplo a continuación, en la línea 6, nos encontramos con una función que se asigna a la variable \colorbox{verylight}{\lstinline{say}}. Y luego en la línea utilizamos ésta variable para invocar la función.

\begin{minted}[fontseries=mc,
               framesep=2mm,
               frame=leftline,
               linenos,
               framerule=0.1pt]{jsx}
function returnSomething(string) {
  return "This is it: " + string;
}

//assigning a function to a variable
let say = returnSomething;

//calling the function
returnSomething("Hello js!");
say("Hello again!");
\end{minted}

Both \mintinline{js}{say} and \mintinline{js}{returnSomething} points to the same place which is the first statement in the body of the function. In the next example, on line 12 we are invoking a function and passing the \mintinline{js}{returnSomething} function as argument. Note how then is invoked on line 8 and its return value returned.

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               linenos]{jsx}
function returnSomething(string) {
  return "This is it: " + string;
}

//receives a function as parameter
//invokes it and return the value
function saySomethingMore(fn) {
  return fn("Hey !");
}

//passing a function as argument
saySomethingMore(returnSomething); //"This is it: Hey !"
\end{minted}

Functions can also be asigned to variables just in its declaration as the next example illustrate:

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               linenos]{jsx}
//assigning the function
const returnSomething = function (string) {
  return "This is it: " + string;
};

returnSomething("Hey !"); //"This is it: Hey !"
\end{minted}

% Rest Parameters
%About parameters, JavaScript accepts an indefinite number of arguments 

%\begin{minted}[fontseries=mc,
%               framesep=5mm,
%               frame=leftline,
%               framerule=0.1pt,
%               linenos]{jsx}
%function restParams(param1, param2, ...params) {
%  params.forEach((element) => {
%    console.log(element);
%  });
%}
%restParams(1, 2, 3, 4, 5);
%\end{minted}

JavaScript provides another and a bit less verbose way to declare functions called \textbf{arrow functions}. Let's see some examples:

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               linenos]{jsx}
               
//arrow function with no parameters
const arrowf1 = () => {
  return "arrowf1 was invoked!";
};

//arrow function with one parameter
//parenthesis is not necesary here
const arrowf2 = param => {
  return "this is the argument: " + param;
};

//arrow functions with one statement 
//in the body won't need return 
const arrowf3 = (a, b) => a + b;
\end{minted}

\section{Arrays} \label{arrays}

\textbf{Arrays} is another very important construction that we will use massively. This is how you can declare an array:

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               linenos]{jsx}
//an empty array
let empty = [];

//an array
let family = ["Jóse", "Nicolas", "Lucia", "Enrique"];
\end{minted}

The elements of an array can be accessed by its index, where the index of the first element is 0.

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               linenos]{jsx}
//an array
let family = ["Jóse", "Nicolas", "Lucia", "Enrique"];
family[0]; //Jóse
family[1]; //Nicolas
family[2]; //Lucia
family[3]; //Enrique
\end{minted}

Adding an element at the end of the array:

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               linenos]{jsx}

let family = ["Jóse", "Nicolas", "Lucia", "Enrique"];

//adding an element at the end of an array
family.push("Pablo");
\end{minted}

And if you want to add the elements of an existing array to another non empty array, you can use what is known as \textit{spread syntax}:

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               linenos]{jsx}

let myParents = ["EnriqueR", "Susana"];
let JoseParents = ["Eduardo", "Graciela"];
let family = ["Jóse", "Nicolas", "Lucia", "Enrique"];
let all = [...myParents, ...JoseParents, ...family];
//[
//  'EnriqueR', 'Susana', 'Eduardo', 'Graciela', 
//  'Jóse', 'Nicolas', 'Lucia', 'Enrique'
// ]
\end{minted}

Spread syntax is also available for functions to accept an indefinite number of arguments:

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               linenos]{jsx}
function restParams(param1, param2, ...params) {
 //params is [3, 4, 5]	
}
restParams(1, 2, 3, 4, 5);
\end{minted}

To simply iterate over an array you can use the following \mintinline{js}{for} construction: 

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               linenos]{jsx}
let family = ["Jóse", "Nicolas", "Lucia", "Enrique"];
for (let element of family) {
  console.log("regular for: ", element);
}
\end{minted}
               
And in addition we have a set of very useful methods. Let's see first how we can iterate over an array using the \mintinline{js}{.forEach} method:               
               
\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               linenos]{jsx}
let family = ["Jóse", "Nicolas", "Lucia", "Enrique"];

family.forEach(function (value, index, array) {
  //value is the element being processed
  //index is the index of the current value
  //array is the entire array
  console.log(value, index, array);
});
\end{minted}

Note that the \mintinline{js}{.forEach} method accepts as parameter a function that accepts three parameters. \mintinline{js}{value} which is the element being processed, the \mintinline{js}{index} which is the index of the value being processed and \mintinline{js}{array} which is the array that we are looping. If you are only interested in the elements you can just do this:

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               linenos]{jsx}
let family = ["Jóse", "Nicolas", "Lucia", "Enrique"];

family.forEach((value) => {
  //do something with the value here	
});
\end{minted}

Another very interested method is \mintinline{js}{.filter}. Similar to the previous one, it receives a function with the same parameters. It will return a new array (shorter or equals than the original) with the elements that evaluates to true to a condition.

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               linenos]{jsx}
let family = ["Jóse", "Nicolas", "Lucia", "Enrique"];

const members = family.filter((member) => {
  return member.length > 5;
});

//members = ['Nicolas', 'Enrique']
\end{minted}

Note that we are passing an arrow function to the \mintinline{js}{.filter} method with a condition testing the length of each element in the \mintinline{js}{family} array. Those element whose length is greater than 5 will be part of the returned new array. Also note that the family array is not changed at all.

The last method we will see is \mintinline{js}{.map}. This method receives a function, same as the previous two methods, and it will return a new array with the result of applying the function to every element. It will always return an array of the same length as the one we are processing. As we will see later, \mintinline{js}{.map} is very used in React to add style markup to the elements of arrays.

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               linenos]{jsx}
let numbers = [1, 2, 3, 4, 5, 6, 7];
const double = numbers.map((element) => {
  return element * 2;
});
//double = [2,  4,  6, 8, 10, 12, 14]
\end{minted}

Array methods can be combined to produce the desire results. Look at the example below. We are applying first the \mintinline{js}{.filter} function to get an array only with odd numbers filter out from the numbers array and to that we are applying \mintinline{js}{.map} to transform it into even numbers.

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               linenos]{jsx}
let numbers = [1, 2, 3, 4, 5, 6, 7];
const chain = numbers
  .filter((element) => {
    return element % 2 !== 0;
  }) //[1, 3, 5, 7]
  .map((element) => {
    return element * 2;
  });
//chain = [2, 6, 10, 14]
\end{minted}

If you have an array with few elements, instead of working with indexes, there is a very convenience way called \textbf{destructuring} that allows you to assign each element of the array to named variables. See below:

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               linenos]{jsx}
let [one, two, three] = [1, 2, 3];
//one = 1
//two = 2
//three = 3

//same as the previous
let fewNumbers = [1, 2, 3];
[one, two, three] = fewNumbers;

//and here using spread syntax
let [a, b, ...rest] = [1, 2, 3, 4, 5];
//a = 1
//b = 2
//rest = [3, 4, 5]
\end{minted}

\section{Objects}\label{jsobjects}

There are several ways to create objects in javacript. We will study those that will be used further in the book when coding in React. The first way to create objects that we will see is called \textbf{Object Literal}. And object literal is created wrapping within curly braces a collection of comma-separated \textit{property}:\textit{value} pairs. 

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               linenos]{jsx}
//an object literal
let mi = {
  name: "Enrique",
  surname: "Molinari",
  sports: ["football", "tennis"],
  address: {
    street: "San Martin",
    number: 125,
  },
  allSports: function () {
    console.log(this.sports);
  },
};
//this is an empty object
let obj = {};
\end{minted}

As you can see an object literal can be composed not only of simple property-value pairs but also for arrays, other objects like \textit{address} and functions (called methods). Additionally, since ES6, you can create object literals with what is called \textit{computed} property names, like shown below on line 6:

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               highlightlines={6},
               linenos]{jsx}
let aproperty = "phone";               
//an object literal with a computed property name 
let mi = {
  name: "Enrique",
  surname: "Molinari",
  [aproperty]: "+54 2920 259031"
};

\end{minted}

Every time the JavaScript interpreter evaluates an object literal a new object is created. 

You can access the properties of an object using the \textbf{dot notation} as the example below shows:

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               linenos]{jsx}
console.log(mi.name); //Enrique
console.log(mi.sports[0]);//football
console.log(mi.address.street);//San Martin
console.log(mi.phone);//+54 2920 259031
mi.allSports(); //invoke the function and prints the sports array               
\end{minted}

You can add properties (and remove too) dynamically to an object. In the example below, on lines 3 and 4 we are adding the properties \mintinline{js}{x} and \mintinline{js}{y} (with their corresponding value) to the \mintinline{js}{obj} object.

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               linenos]{jsx}
let obj = {a: 1, b: 2};
//add properties to the obj object
obj.x = 3;
obj.y = 4;
\end{minted}

The spread syntax also works with objects, see below:

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               linenos]{jsx}
let obj1 = {
  a: 1,
  b: 2,
};
let obj2 = {
  c: 3,
  d: 4,
};
let obj3 = { ...obj1, ...obj2 };
//obj3 = { a: 1, b: 2, c: 3, d: 4 }
\end{minted}

And if you want to create an object from some declared variables, you can do this:

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               linenos]{jsx}
let a = 1,
  b = 2;
let obj4 = {
  a,
  b,
};
//obj4 = { a: 1, b: 2 }	
\end{minted}

So far we have seen object literal syntax and what you can do with it. But what if you don't know how many object you will need to create? You need something like a \textit{class} from class-based languages like Java or C++. In JavaScript, we have what is called \textbf{constructor functions}. As we will see later, JavaScript have added classes to the language, but they are just syntactic sugar on top of functions.

A constructor function name by convention start with a capital letter. Lets see how to create and use them:

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               linenos]{jsx}
function Book(name, authors, publishedYear) {
  this.name = name;
  this.authors = authors;
  this.publishedYear = publishedYear;
  this.fullName = function () {
    return this.name + " by " + this.authors + ". " + publishedYear;
  };
}

thisBook = new Book("Coding in React", 
			["Enrique Molinari"], 2021);
thisBook.fullName(); //Coding in React by Enrique Molinari. 2021

archBook = new Book("Coding an Architecture Style", 
			["Enrique Molinari"], 2020);
archBook.fullName(); //Coding an Architecture Style by Enrique Molinari. 2020 
\end{minted}

As you can see, the function \mintinline{js}{Book} looks like a class's \textit{constructor} of a class-based language, in which, in addition, we are able to declare right there methods like \mintinline{js}{fullName()}. We define properties and we initialise them with the function parameters on lines 2, 3 and 4. On line 5 we define a method. After that, on lines 10 and 14 we are creating two instances of two different books and then invoke the \mintinline{js}{fullName()} method. Constructor functions is the syntactical construction that JavaScript offers to create object oriented software.

\subsection{A Prototype-Base Language}

Now that we know how to create objects literals, constructor functions and create instances from them, it is time to explain what it means for JavaScript to be a \textbf{prototype-based} language. Prototype-based languages are a style of object oriented programming in which objects are created without creating \textit{classes}. That is why they are also called \textit{classless} languages, in contrast to \textit{class-based} object oriented languages (like Smalltalk, Java, C++ and C\# to name a few). In prototype-based languages there are no classes, just objects. We don't have that difference between classes and objects. That difference between a \textit{static} definition of a blueprint (a class) and their inheritance relationship (which cannot be changed at runtime) vs the \textit{dynamic} instantiation (object creation). And not having classes vs objects becomes evident in some situations like the ones we will see next. 
Defining methods in constructors functions in the way we did before it is not ideal due to for each instance that we will create we are adding the method \mintinline{js}{fullName()} to it. This can be illustrated with the code below:

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               linenos]{jsx}
thisBook = new Book("Coding in React", 
			["Enrique Molinari"], 2021);
archBook = new Book("Coding an Architecture Style", 
			["Enrique Molinari"], 2020);
//printing thisBook
//Book {
//  name: 'Coding in React',
//  authors: [ 'Enrique Molinari' ],
//  publishedYear: 2021,
//  fullName: [Function (anonymous)]
//}
//printing archBook
//Book {
//  name: 'Coding an Architecture Style',
//  authors: [ 'Enrique Molinari' ],
//  publishedYear: 2020,
//  fullName: [Function (anonymous)]
//}
\end{minted}

As you can see in the previous example code, the two instances of the Book constructor function includes, in addition to the the property names (and their values), the function implementation code. Source code is not shared across the instances like it is in class-based languages. This is an implementation detail of the language which if you are not aware of it might lead to inefficient programs. And what about \textit{inheritance} which is a valuable language resource used by developers? If there are no classes, do we have inheritance? Yes, we have something similar to the classic inheritance that you know from class-based languages. The difference, among others, is that this relation is dynamic, meaning that the inheritance relationship in prototype-based languages can be changed at runtime (as opposed to class-based languages where inheritance is a static relationship that cannot change at runtime). Here is where we have to introduce the concept known as \textbf{prototype}. We can deal with the duplication in the definition of the method and implement inheritance using it. 
\newline

Each object in JavaScript can have a \textbf{prototype} object, to \textit{inherit} properties and method from it. If you call a property or method in an object and is not defined there, it will \textbf{delegate} that call to its prototype. Since that prototype object might have a prototype object too, this delegation will follow until is found or fail with an error. This is called as \textbf{prototype chain}. 
\newline

Each constructor function have access to a special property called prototype, that can be accessed using dot notation: \mintinline{js}{Book.prototype}. And when you create an instance, you can also access (while in general is not necessary) to this property using: \mintinline{js}{thisBook.__proto__} or which is the same:\\ \mintinline{js}{Object.getPrototypeOf(thisBook)}.

Knowing this we can improve our \mintinline{js}{Book} constructor function defined above in the following way:

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               linenos]{jsx}
function Book(name, authors, publishedYear) {
  this.name = name;
  this.authors = authors;
  this.publishedYear = publishedYear;
}
Book.prototype.fullName = function () {
  return this.name + " by " + this.authors + ". " + this.publishedYear;
};               
               
thisBook = new Book("Coding in React", 
			["Enrique Molinari"], 2021);
archBook = new Book("Coding an Architecture Style", 
			["Enrique Molinari"], 2020);
//printing thisBook
//Book {
//  name: 'Coding in React',
//  authors: [ 'Enrique Molinari' ],
//  publishedYear: 2021
//}
//printing archBook
//Book {
//  name: 'Coding an Architecture Style',
//  authors: [ 'Enrique Molinari' ],
//  publishedYear: 2020
//}
\end{minted}

In the example above we have defined the method \mintinline{js}{fullName()} in the prototype of the constructor function (line 6). After that, on lines 10 and 12 we are creating two instances and then printing them. Now as you can see the \mintinline{js}{fullName()} method is not there because it now belongs to their prototype object, shared by the two \mintinline{js}{Book} instances: \mintinline{js}{thisBook} and \mintinline{js}{archBook}. So, what happen if we execute the following:

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               linenos]{jsx}

thisBook.fullName();
\end{minted}

JavaScript will first find the \mintinline{js}{fullName()} method in the \mintinline{js}{thisBook} instance. As it is not defined there, JavaScript will then look in their prototype object and because its there it will be called. 

Every prototype chain will end up points to \mintinline{js}{Object.prototype}. So, if you execute the following:

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               linenos]{jsx}

thisBook.valueOf();
\end{minted}

JavaScript will try to find the method \mintinline{js}{valueOf()} in the \mintinline{js}{thisBook} instance. Then on their prototype and finally on the prototype object of their prototype, which is \mintinline{js}{Object.prototype}. The method is there, so it is called.

Lets now create a basic inheritance example. We are going to create a new \mintinline{js}{EBook} constructor function that will inherit from \mintinline{js}{Book}.

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               breaklines=true,
               linenos]{jsx}

function EBook(filesize, name, authors, publishedYear) {
  Book.call(this, name, authors, publishedYear);
  this.filesize = filesize;
}
let eBook = new EBook(2048, "Coding in React", ["Enrique Molinari"], 2021);

//printing eBook:
//eBook:  EBook {
//  name: 'Coding in React',
//  authors: [ 'Enrique Molinari' ],
//  publishedYear: 2021,
//  filesize: 2048
//}
\end{minted}

Above we have defined the \mintinline{js}{EBook} constructor function. On line 2 we are invoking the \mintinline{js}{Book} constructor function using the \mintinline{js}{call} method which allows us to set the value of \mintinline{js}{this} as the current object. This is, somehow, analogous to the use of \mintinline{js}{super(...)} inside a constructor in a class to instantiate the parent class and initialise their private members. On line 5 we are creating an instance of \mintinline{js}{EBook} and if we print the instance on the console we can see that now we have all the properties from the \mintinline{js}{Book} constructor functions on the \mintinline{js}{eBook} object. However, we don't have yet the \mintinline{js}{fullName()} method that was defined in the \mintinline{js}{Book.prototype}. To inherit that method in the \mintinline{js}{EBook} instances we have to set the \mintinline{js}{Book.prototype} object as the prototype of the \mintinline{js}{eBook} instance. We do that below:

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               linenos]{jsx}

Object.setPrototypeOf(eBook, Book.prototype);

//Another way of doing the same as above is this:
//thisEBook.__proto__ = Book.prototype;
//However __proto__ is deprecated
\end{minted}

\mintinline{js}{Object.setPrototypeOf} is a method where the first parameter is the instance to have its prototype set and the second parameter is the prototype object to be set.

\section{Classes}

Yes! JavaScript has classes and their syntax is pretty similar to most of the class-based languages you might know. They were added to the language in 2015 as part of the EcmaScript 6. The thing is that classes in JavaScript are a syntactic sugar on top of constructor functions and prototype inheritance. Behind the scene, everything works like a prototype-base language, even if you define instances from classes. That is why it is important to understand the previous sections.

We will implement our \mintinline{js}{Book} and \mintinline{js}{EBook} constructor functions with prototype inheritance from the previous section but using classes.

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               breaklines=true,               
               linenos]{jsx}

class Book {
  constructor(name, authors, publishedYear) {
    this.name = name;
    this.authors = authors;
    this.publishedYear = publishedYear;
  }

  //this method gets added to the Book.prototype
  fullName() {
    return this.name + " by " + this.authors + ". " + this.publishedYear;
  }
}

class EBook extends Book {
  constructor(filesize, name, authors, publishedYear) {
    super(name, authors, publishedYear);
    this.filesize = filesize;
  }
}
\end{minted}

What we did in the above example with classes, the \mintinline{js}{EBook} and \mintinline{js}{Book} inheritance relationship is the same as what we did with the \mintinline{js}{EBook} and \mintinline{js}{Book} constructor functions in the section before. See the following code that demonstrate this:

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               breaklines=true,               
               linenos]{jsx}

let ebook = new EBook(2048, "Coding in React", ["Enrique, Molinari"], 2021);
//Book.prototype is the prototype of the ebook instance
console.log(Book.prototype.isPrototypeOf(ebook)); //true
//fullName method is found on the prototype
console.log(ebook.fullName()); //Coding in React by Enrique, Molinari. 2021
//EBook is a function not a class
console.log(typeof EBook); //function
\end{minted}

In the example above, we first create an instance of \mintinline{js}{EBook} and then on line 3 we verify that \mintinline{js}{Book.prototype} is the prototype of the \mintinline{js}{ebook} instance. This means that the inheritance relationship was implemented as prototypes just like functions.

\section{The Multiple Meanings of \textit{this}} \label{meaning_of_this}

It is important to understand how \mintinline{js}{this} works in JavaScript as it depends on where it is used, how it behaves. We have been using \mintinline{js}{this} in the examples from the previous sections in constructor functions and in classes. And we have not mentioned anything about it because in those examples it behaves just like you know from class-based languages like Java or C\#. However, there are some details you should know specially if you your classes for your React components.

So far, if you use \mintinline{js}{this} in constructor functions and classes, and creates the instances using the \mintinline{js}{new} keyword, \mintinline{js}{this} is bind to the object being instantiated. However, specifically with constructor functions this won't work as expected if you just call the function like in the next example: 

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               breaklines=true,               
               linenos]{jsx}
function Constr(param) {
  this.param = param;
}

Constr(2); //this is global object window
console.log(window.param); //prints 2
\end{minted}

Calling the constructor function as we are doing on line 5 will bind \mintinline{js}{this} to the \textit{window} global object. So, this example works perfect, but what it does is probably something you don't expect. This example will end up adding the \mintinline{js}{param} property to the \textit{window} object and assigning it the value \mintinline{js}{2}.

So, \mintinline{js}{this} will bind to the \textit{window} global object if you use it in regular functions. As we have seen, in classes works as expected, it will bind to the object being instantiated. However, if you need to assign or pass as an argument a method from a class that method will lose the binding of \mintinline{js}{this}. Let study the next example:

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               breaklines=true,               
               linenos]{jsx}

class Person {
  constructor(name) {
    this.name = name;
  }
  saySomething() {
    console.log(this.name + " is talking...");
  }
}
let enrique = new Person("Enrique");
enrique.saySomething(); //Enrique is talking...

let o = enrique.saySomething; //assigning to a variable
o(); //TypeError: Cannot read property 'name' of undefined
\end{minted}

In the previous example we are defining a class \mintinline{js}{Person}. Then on line 9 we are creating an instance \mintinline{js}{enrique} and on line 10 we are invoking the \mintinline{js}{saySomething()} method. When the method is invoked since \mintinline{js}{this} is bind to the object \mintinline{js}{enrique}, \mintinline{js}{this.name} which was initialised to the \mintinline{js}{"Enrique"} string will works and prints "Enrique is talking...". However, on line 12 we are assigning the method to a variable and then using the variable to invoke the method on line 13. At the invocation of the \mintinline{js}{saySomething()} method (by the \mintinline{js}{o()} call), \mintinline{js}{this} is \mintinline{js}{undefined}, it is not bind to the object \mintinline{js}{enrique}. Then we will get a \textit{TypeError} message saying that \mintinline{js}{name} is not a property of \mintinline{js}{undefined}. 

In order to fix this, we have to explicitly bind the value of this as we see next:
 
\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               breaklines=true,
               highlightlines={4},               
               linenos]{jsx}

class Person {
  constructor(name) {
    this.name = name;
    this.saySomething = this.saySomething.bind(this);    
  }
  saySomething() {
    console.log(this.name + " is talking...");
  }
}
let enrique = new Person("Enrique");
enrique.saySomething(); //Enrique is talking...

let o = enrique.saySomething; //assigning to a variable
o(); //Enrique is talking...
\end{minted}

On line 4 above we are explicitly binding the value of \mintinline{js}{this}, which in the constructor is the object being instantiated, to the \mintinline{js}{saySomething} method. In this case when \mintinline{js}{saySomething} is invoked by the \mintinline{js}{o()} call it will work as expected. Another way to fix this is by declaring the methods as \textit{arrow functions}.

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               breaklines=true,
               highlightlines={5},               
               linenos]{jsx}

class Person {
  constructor(name) {
    this.name = name;
  }
  saySomething = () =>  {
    console.log(this.name + " is talking...");
  }
}
let enrique = new Person("Enrique");
enrique.saySomething(); //Enrique is talking...

let o = enrique.saySomething; //assigning to a variable
o(); //Enrique is talking...
\end{minted}

Defining the method using the \textit{arrow function} syntax will work because arrow functions retain the \mintinline{js}{this} value of the enclosing lexical scope which in this case is the class. However, arrow functions in classes will not get added to the prototype of the object being instantiated, which means, as we have already discussed, that every instance will have its own copy of the method.

\section{Modules}
%modules
The 6th edition of ECMAScript in 2015 has added, in addition to classes, the possibility of defining modules. Before this release there were other options to create modular JavaScript programs using tools like RequireJS \cite{requirejs}, among many others. Now we have this functionality supported natively by modern browsers.

Its use is pretty simple. You can define functions, classes, objects, constants in a JavaScript file and \mintinline{js}{export} those that you want to be reused by others. And in addition a client module must \mintinline{js}{import} those that needs to reuse. Lets see some code examples.

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               breaklines=true,
               linenos]{jsx}
//this is my complex-module.js module

export function complexThing() {
  console.log("a complex thing has been executed...");
}

export let obj = {
  a: 1,
  b: 2,
};

export class ASimpleClass {
  constructor(name) {
    this.name = name;
  }

  print() {
    console.log("printing: ", this.name);
  }
}
\end{minted}

In the module \textit{complex-module.js} we are exporting a function, and object and a class. We can also write the same using a different syntax:

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               breaklines=true,
               highlightlines={22},               
               linenos]{jsx}
//this is my complex-module.js module

function complexThing() {
  console.log("a complex thing has been executed...");
}

let obj = {
  a: 1,
  b: 2,
};

class ASimpleClass {
  constructor(name) {
    this.name = name;
  }

  print() {
    console.log("printing: ", this.name);
  }
}

export { obj, ASimpleClass, complexThing };
\end{minted}

Everything can be \mintinline{js}{exported} at the end just like we are doing on line 22 above. Of course, you don't have to export everything from a module, just those abstractions that represent the public API of your module. Let's see below how you can \mintinline{js}{import} the abstraction from the \textit{complex-module.js}.

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               breaklines=true,
               highlightlines={22},               
               linenos]{jsx}
//this is my main-module.js module

import { complexThing, obj, ASimpleClass } from "./module/complex-module.mjs";

//calling the imported function
complexThing();

//printing the imported object
console.log(obj);

//instantiating the imported class
let o = new ASimpleClass("Enrique");
o.print();
\end{minted}

As you can see on line 3 we are importing the three abstractions that the module exports. And the we are just able to use them as if the were declared in the \textit{main-module.js} file.

There is a common practice to define a \mintinline{js}{default export} abstraction from a module in order that client module can import those a bit easier. In the code below, on line 22, we are exporing the class as our default exported abstraction from the module.

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               breaklines=true,
               highlightlines={22},               
               linenos]{jsx}
//this is my complex-module.js module

function complexThing() {
  console.log("a complex thing has been executed...");
}

let obj = {
  a: 1,
  b: 2,
};

class ASimpleClass {
  constructor(name) {
    this.name = name;
  }

  print() {
    console.log("printing: ", this.name);
  }
}

export default ASimpleClass;
export { obj, complexThing };
\end{minted}

On line 3 below, note how we are importing the default exported abstraction with a different name (it is an alternative, but we can use the same name). Note also that there are no curly braces.

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               breaklines=true,
               highlightlines={3},               
               linenos]{jsx}
//this is my main-module.js module

import AClass from "./module/complex-module.mjs";
//This line below is the same as the one above
//import { default as AClass } from "./module/complex-module.mjs";
import { obj, complexThing } from "./module/complex-module.mjs";

let o = new AClass("Enrique");
o.print();

//... more code here
\end{minted}


\section{Single Thread Language} \label{single_thread}

As per the definition about JavaScript we gave at the beginning of this chapter, we know that JavaScript is a \textbf{single threaded} language. This means that the execution of a statement is one at a time. However, as we know, JavaScript supports \textit{asynchronous} operations, like Ajax calls. So, how does this work? The thing is that the JavaScript interpreter receives some help from the Browser, where somehow, as we will see later, are returned to the JavaScript interpreter as \textit{callbacks}. There are a bunch of operations that the JavaScript interpreter delegates its execution to the Browser. These operations are called \textbf{Web APIs}. Among these Web APIs, we can find events (onclick, onmouseover, etc), fetch and XMLHttpRequest (ajax calls), setTimeout, etc.

To handle this, the execution environment of JavaScript has use: a \textit{call stack}, the browser's Web APIs, a \textit{callback queue} and its \textit{event loop}. Lets see the following simple example:

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               breaklines=true,
               linenos]{jsx}
console.log("starting");

setTimeout(() => {
  console.log("callback");
}, 1000);

console.log("finishing");
\end{minted}

Here is the list of how this program is executed in a browser:
\begin{enumerate}
\item Statement on line 1 is pushed on to the \textit{call stack} and executed. \mintinline{js}{"starting"} is printed on the console. 
\item The \mintinline{js}{setTimeout} on line 3 is delegated to the browser's Web API to be executed. Which basically wait for one second. However execution of the program continue, does not wait because the execution was delegated to the browser's Web API.
\item Statement on line 7 is pushed on to the \textit{call stack} and executed. \mintinline{js}{"finishing"} is printed on the console.
\item After the one second elapsed from the \mintinline{js}{setTimeout} function, the callback arrow function passed as the first argument is then pushed into the \textit{callback queue}. Since there are no more statements to be executed on the \textit{call stack}, the \textit{event loop} get from the top of the \textit{callback queue} the arrow function and push it into the \textit{call stack}. Finally it gets executed. \mintinline{js}{"callback"} is printed on the console.
\end{enumerate}

Note that all the callback functions that end up in the \textit{callback queue} gets executed after the call stack is empty and not before. To be very clear with this, look a the example below.

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               breaklines=true,
               highlightlines={5},                              
               linenos]{jsx}
console.log("starting");

setTimeout(() => {
  console.log("callback");
}, 0);

console.log("finishing");
\end{minted}

Note that on line 5 we are passing \mintinline{js}{0} seconds to the \mintinline{js}{setTimeout} function telling the Web API to not wait to push the callback arrow function into the \textit{callback queue}. In any case, the result and the order of the console messages is the same as the example before: \mintinline{js}{"starting"}, \mintinline{js}{"finishing"}, \mintinline{js}{"callback"}.

We can expect exactly the same behaviour from the example below that perform an ajax call:

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               breaklines=true,
               linenos]{jsx}
console.log("starting");
fetch("https://jsonplaceholder.typicode.com/posts/1")
  .then((response) => response.json())
  .then((json) => console.log(json));
console.log("finishing");
\end{minted}

\mintinline{js}{fetch} is delegated to the Web API which performs an ajax call. Once the server respond, the callback arrow functions are pushed into the \textit{callback queue}. The first callback function, on line 3, transform the response obtained from the server to json and the next callback function on line 4 prints that json in the console. Only after printing on the console the text \mintinline{js}{"finishing"} on line 5, is when those callbacks functions are pushed into the \textit{call stack} and executed. You can find a more detailed explanation about the JavaScript interpreter and how it works, in the great talk by Philip Roberts\cite{loupe}.

\section{The Promise Object and the async/await Keywords}

The Promise Object was introduced in Javascript in ES2015. This object represents an asynchronous operation that might finish successfully or fail. See below how to create an instance of a Promise:

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               breaklines=true,
               linenos]{jsx}
let p = new Promise(function (resolve, reject) {
  //function to be executed by the constructor
});

//do something with p
\end{minted}

As we can see above, the Promise constructor receives a function, called \textit{executor}, that will be invoked by the constructor. The \textit{executor} function receives two additional functions as parameters. The body of the \textit{executor} function perform typically an asynchronous operation and finish by calling the \mintinline{js}{resolve(value)} function if everything goes well or \mintinline{js}{reject(reason)} otherwise. See how this is done bellow:

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               breaklines=true,
               linenos]{jsx}
let p = new Promise(function (resolve, reject) {
  //long async operation
  setTimeout(() => resolve("finished"), 1000);
});
\end{minted}

On the example above using \mintinline{js}{setTimeout} we are simulating an operation that takes one second to finish. After that operation finish it will call the \mintinline{js}{resolve} function passing as value the string \mintinline{js}{"finished"}. What can we do with that then?
\newline

The Promise object have the \mintinline{js}{then(handleResolved)} method that receives a function that allows you to work with the parameter passed when you invoke the \mintinline{js}{resolve} function like we do on line 3 below:   

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               breaklines=true,
               highlightlines={6},
               linenos]{jsx}
let p = new Promise(function (resolve, reject) {
  //long async operation
  setTimeout(() => resolve("finished"), 1000);
});

p.then((value) => console.log(value));
\end{minted}

As we can see above, on line 6 we are passing the \mintinline{js}{"finished"} string as parameter named \mintinline{js}{value} to the function passed to the \mintinline{js}{then(handleResolved)}. Then that value is just printed. What is important to note here is that the \mintinline{js}{handleResolved} function passed to the \mintinline{js}{then(...)} method is executed only once the promise is resolved.
\newline

Suppose now something goes wrong withing the executor, then it can be handled in a different way, see below:

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               breaklines=true,
               linenos]{jsx}
let p = new Promise(function (resolve, reject) {
  //long async operation
  setTimeout(() => reject("can't be done..."), 1000);
});

p.then((value) => console.log("success: " + value))
 .catch((value) => console.log(value));
\end{minted}

Note that on line 3 now we are calling the \mintinline{js}{reject(reason)} function passing the \mintinline{js}{reason} value as the string \mintinline{js}{"can't be done"}. Then, on line 7 note how the function passed to the \mintinline{js}{catch} method is the one that gets called.  
\newline

During this book, and usually in React we don't write promises, but we use them frequently. By using the \mintinline{js}{fetch} method to retrieve data from an external API, we have to deal with a promise. Look at the example below:

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               breaklines=true,
               linenos]{jsx}
function fetchPost() {
 fetch("https://jsonplaceholder.typicode.com/posts/1")
  .then((response) => response.json())
  .then((json) => console.log(json));
}

fetchPost();
\end{minted}

As you can see on line 2 above, the \mintinline{js}{fetch} method call returns a promise, which allows us to call the \mintinline{js}{then} method on it, to work with the fetched data.
\newline

Another way to write this is by using the \mintinline{js}{async} and \mintinline{js}{await} keywords. These keywords were added to Javascript on ES2017 allowing us to write asynchronous code in a synchronous way. Let's rewrite one of our previous examples to take advantage of these keywords. First we will create a function that return a promise. Functions that return promises are (usually) asynchronous:  

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               breaklines=true,
               linenos]{jsx}
function thePromise() {
  return new Promise(function (resolve, reject) {
    //long async operation
    setTimeout(() => resolve("finished"), 1000);
  });
}
\end{minted}

To call these functions the \mintinline{js}{await} keyword is used provoking to stop the execution until the promise is \mintinline{js}{resolved} or \mintinline{js}{rejected}. The call code must be a function declared with the \mintinline{js}{async} keyword. See below: 

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               breaklines=true,
               linenos]{jsx}
async function testingKeywords() {
  console.log("before");
  const data = await thePromise();
  console.log("after");
  console.log(data);
}
\end{minted}

Note that we declared the function \mintinline{js}{async}, line 1, and we use the \mintinline{js}{await} keyword before calling the asynchronous function on line 3. It is important to understand that the order of the messages printed on the console is the same as the order of the sentences inside the \mintinline{js}{testingKeywords()} function, as opposed to what we have discussed before on section \ref{single_thread}.
\newline

To finish this section we are going to rewrite the \mintinline{js}{fetchPost()} function to use these new keywords. See below:

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               breaklines=true,
               linenos]{jsx}
async function fetchPost() {
  let data = await fetch("https://jsonplaceholder.typicode.com/posts/1");
  data = await data.json();
  console.log(data);
}

fetchPost();
\end{minted}

As you can see, again, we are declaring the function \mintinline{js}{async}, and in  this case the \mintinline{js}{fetch} call on line 2, is prepended with the \mintinline{js}{await} keyword. Prepended the \mintinline{js}{await} to the \mintinline{js}{fetch} function means that instead of returning a \href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise}{Promise} object, it returns (if the promises resolve, you can use a try/catch block to handle errors) a \href{https://developer.mozilla.org/en-US/docs/Web/API/Response}{Response} object. That allows us to call on line 3 directly to the \mintinline{js}{json()} method of the \href{https://developer.mozilla.org/en-US/docs/Web/API/Response}{Response} object. As that method returns a Promise, we also prepend the sentence with the \mintinline{js}{await} keyword, giving us a Javascript object that is finally printed on the console.
\newline

It is important to note that \mintinline{js}{await} can only be used inside an \mintinline{js}{async} function.

\part{Understanding React}

\chapter{Essential React Concepts}

In this chapter we will learn the core concepts behind react.  

\section{React Principles} \label{react_mindset}

%Introduction to Thinking with React Components - libro react workshop

%https://reactjs.org/docs/design-principles.html
I have to start saying that I \textit{love} React! I love it because I love designing software in a professional way. With that I mean with practices that keeps application's source code \textit{modifiable} after several years of changing it. We say a software is modifiable, if I know on every change, where that change will impact. The best feature of React is their components construction. Yes... components. That piece of software very well described in text by several books, but very rare provided by programming languages in a good way. React components challenge the design pattern found in most of the best known frameworks and libraries, which are based on logic separated from markup,by using template languages to style data. React components suggest that UI logic and markup must be naturally grouped in the same abstraction. And that is their power, what makes React so great and the reason I love it. And among other features provided by React, understanding how to build application by assembling components is the main goal of this book. 
\newline

After reading this book, I really recommend to see the explanation about react design principles by Pete Hunt: \href{https://www.youtube.com/watch?v=DgVS-zXgMTk}{React - Rethinking Best Practices}.

%TBD: Separation of technologies vs concerns
%React separa concerns functionales, otras sobre tecnologias.

%With JQuery you might be able to create plugins to build reusable components. With %React you can create reusable components too, but what it is more important, you %can split an application into components to support maintainability.To support %large-scale Web client applications. Why? because splitting the application into %components will give you the light to see where each new change will impact.

\section{Creating a React Project} \label{create_react_project}

To start with React we will first create a React project using a tool called \href{https://github.com/facebook/create-react-app}{Create React App}. With this tool as you will see, you can create a starter React project without configuration. In order to use this tool, install on your local development machine the latest LTS version of \href{https://nodejs.org/}{Node.js}.

After that, run the following command on the console to create your first React project:

\begin{minted}[fontseries=mc,
               framesep=2mm]{console}
$ npx create-react-app coding_in_react
\end{minted}

When finish, if everything went fine, you will see a message like:

\begin{minted}[fontseries=mc,
               framesep=2mm]{console}
Success! Created coding_in_react at /home/react/coding_in_react
\end{minted}

Run the following commands to start your application:

\begin{minted}[fontseries=mc,
               framesep=2mm]{console}
$ cd coding_in_react
$ npm start
\end{minted}

That will open your default browser with the URL http://localhost:3000/, with a sample application running. Lets now open VS Code to see what is inside our project folder. To do that, you can type on your console the following: 

\begin{minted}[fontseries=mc,
               framesep=2mm]{console}
$ cd coding_in_react
$ code .
\end{minted}

This will open VS Code with the project folder \mintinline{console}{coding_in_react} ready to be used. Lets have a look at the project folder structure below. There is a brief explanation of what is each item.
\newline

\dirtree{%
.1 coding\_in\_react.
.2 node\_modules \begin{minipage}[t]{11cm}
\textcolor{gray}{This folder contains packages installed by the Create React App tool{.}Any package that we install will end up here{.}}
\end{minipage}.
.2 public \begin{minipage}[t]{13cm}
\textcolor{gray}{This folder contains the index.html file (among others) which creates the main skeleton layout of your web application{.}}
\end{minipage}.
.2 src \begin{minipage}[t]{15cm}
\textcolor{gray}{This is the folder where your React source files will reside{.}}
\end{minipage}.
.2 package-lock.json \begin{minipage}[t]{11cm}
\textcolor{gray}{Here you will find the exact version of each of the packages (and the dependencies of the packages) that your project depends on{.}This file should be changed only by using npm commands{.}}
\end{minipage}.
.2 package.json \begin{minipage}[t]{11cm}
\textcolor{gray}{Here you will find the packages that your project depends on{.}This file should be changed only by using npm commands{.}}
\end{minipage}.
.2 README.md \begin{minipage}[t]{12cm}
\textcolor{gray}{This is a Markdown file that contains documentation about the project{.}}
\end{minipage}.
}

In the next section we will start coding in React using this project. I will refer to the folders and files there when necessary.

\section{React Components} \label{react_component}

React applications are built by creating components. Component is probably one of the most confusing terms in software engineering. So, we will provide our definition of what a component is in React. A React component is a self contained piece of software that is created by using the JavaScript \mintinline{js}{class} definition or the JavaScript \mintinline{js}{function} definition. It manage its own state and ideally perform a single task. It might collaborate with other components and knows how to paint itself on the browser.

In the previous paragraph I said that React components knows how to paint itself in the browser and they can be defined using the \mintinline{js}{class} or the \mintinline{js}{function} syntactical constructions. If you use a \mintinline{js}{class} you have to add a method called \mintinline{js}{render}, which is the method invoked by the React runtime to paint the component in the browser. And if you use a \mintinline{js}{function}, you just provide there the implementation of its render.

Lets create our first React component using a JavasScript \mintinline{js}{class}:

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               breaklines=true,
               linenos]{jsx}
import { Component } from "react";

export default class Person extends Component {
  render() {
    return <p>This is a <strong>Person</strong> Component</p>;
  }
}
\end{minted}

You first need to \mintinline{js}{import} the \mintinline{js}{Component} class from React Core, because your JavaScript classes must \mintinline{js}{extends} from it. And finally you have to define the \mintinline{js}{render} method that is in charge to paint the component on the browser. Note that this method just \mintinline{js}{return} HTML (or at least looks like HTML as we see later). See below the same component as the on above but using a \mintinline{js}{function} definition instead of a class:

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               breaklines=true,
               linenos]{jsx}
export default function Person() {
  return <p>This is a <strong>Person</strong> Component</p>;
}
\end{minted}

\section{Rendering Components}

I have my first component, how do I get it render into the DOM? To answer to this question we will learn some React concepts.

Take a look again at the component we have created in section \ref{react_component}, the "HTML" snippet that the function component return (or the render method in the clas based component) is not really HTML. It is called \href{https://reactjs.org/docs/introducing-jsx.html}{JSX}, which stands for \textbf{JavaScript XML}. It is a \textit{syntax extension} to JavaScript and what the React team recommends to use to paint your components on the browser.
\newline 

In JSX, you can embed any valid \href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators#expressions}{JavaScript Expression} between curly braces. As an example, below you can see the variable \mintinline{js}{name} declared and initialised (on line 2) and used inside the JSX syntax (line 6). 

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               breaklines=true,
               linenos]{jsx}
export default function Animal() {
  let name = "Eze the Dog";

  return (
    <p>
      This is <strong>{name}</strong>
    </p>
  );
}
\end{minted}

Browsers does not understand JSX syntax. To make it work we have to translate JSX into JavaScript, using a compiler like \href{https://babeljs.io/}{Babel}. If you create your React application using the \mintinline{console}{create-react-app} tool like we did before, you get this covered and you can forget completely about this.
\newline 

Once this compilation is done, JSX gets translated into a JavaScript expression which at execution time, is evaluated along with the expressions defined by you in curly braces and painted on the browser.
\newline 

As JSX are expressions, it is possible to see a JSX piece of code as a first class citizen. Which allows you to do, for instance, what you see below:

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               breaklines=true,
               linenos]{jsx}
function passingAsArgument(jsx) {
  return jsx;
}

export default function Animal() {
  let name = "Dog";
  //assign a JSX block to a variable
  let jsx = passingAsArgument(
    <p>
      This is a <strong>{name}</strong>
    </p>
  );

  return jsx;
}
\end{minted}

In the example above, we are calling a function passing a JSX expression as an argument and the return of that function (which is just this same argument) is assigned to the variable \mintinline{js}{jsx} on line 8.
\newline

JSX is also the way you use to render your own components. In the VS Code project we have created in section \ref{create_react_project}, create a JavaScript file called \mintinline{console}{src/Person.js} with the \mintinline{js}{Person} component we have created in section \ref{react_component}. Then, open the file \mintinline{console}{src/index.js} and paste the following:

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               breaklines=true,
               highlightlines={7},                              
               linenos]{jsx}
import React from "react";
import ReactDOM from "react-dom";
import Person from "./Person";

ReactDOM.render(
  <React.StrictMode>
    <Person />
  </React.StrictMode>,
  document.getElementById("root")
);
\end{minted}

The \mintinline{console}{src/index.js} file is our JavaScript main module (the entry point), so it is the place to describe the UI of our application. In the main file we have to call the \mintinline{js}{ReactDOM.render} function, which expects as their first argument a JSX expression, and then the DOM element in which the JSX expression will be rendered. If you check the \mintinline{console}{public/index.html}, you will see the markup \mintinline{html}{<div id="root"></div>} we are referencing on line 9 above. 

\begin{displayquote}
{\small When you you create a React project with \mintinline{console}{create-react-app} as we did, there are several things that happens unders the hood. One is the translation of JSX to JavaScript as we mentioned. But there are few others that are important to understand. \mintinline{console}{create-react-app} uses \href{https://webpack.js.org/}{Webpack}, a static module bundler to help improve the performance of your application by combining multiple static files into one, which reduces the number of request the browser requires to do to the server to get static assets. Specially when you build a single page application with JavaScript tools like this becomes very important. So, Webpack unders the hook, takes the \mintinline{console}{src/index.js} as the \href{https://webpack.js.org/concepts/#entry}{entry point} to produce the bundler. I use the \mintinline{console}{public/index.html} as the HTML template, which change to inject an \mintinline{html}{<script>} tag with the path to the js bundler. This magic happens when you run \mintinline{console}{npm start} and \mintinline{console}{npm run build}. You can check \href{https://stackoverflow.com/questions/42438171/wheres-the-connection-between-index-html-and-index-js-in-a-create-react-app-app}{this explanation} directly from one of the React core developers.}
\end{displayquote}

On line 7 we are telling React to render our Person component. That will instantiate the Person \mintinline{jsx}{class} and execute the \mintinline{jsx}{render} method, in the case of the class based component, or execute the Person \mintinline{jsx}{function} in the case of the function based component. In either case, the output is inserted into the DOM, generating what is shown below:

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               breaklines=true,
               highlightlines={2},                              
               linenos]{html}
<div id="root">
 <p>This is a <strong>Person</strong> Component</p>
</div>
\end{minted}

In the \mintinline{console}{src/index.js}, the \mintinline{jsx}{<Person/>} component is wrapped by \mintinline{jsx}{<React.StrictMode>} component which helps us in development informing us about potential problems with our React code. Have a look at \href{https://reactjs.org/docs/strict-mode.html}{strict mode} in React official docs.

Note that component names, in this case Person, start with capital letter. React sees components starting with capital letter as custom components and that requires the function or class definition to be in scope. And it sees components starting with lowercase letter as DOM tags, like div, p, strong, etc.

\subsection{Styling}

Here we describe how you can add styling to your React components. In the example below we are adding style to a component using a CSS file.

\begin{listing}[H]
\title{./StyleDemo.css}
\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               breaklines=true,
               linenos]{css}
.big {
  background-color: red;
  height: 200px;
  width: 200px;
  font-size: 30px;
  color: blue;
}

.small {
  background-color: green;
  height: 40px;
  width: 40px;
  font-size: 14px;
  color: black;
}
\end{minted}
\end{listing}

Below, on line 1 we are first importing the CSS file we shown above which is located in the same directory of the component. Note that on lines 8 and 9 we are using the \mintinline{jsx}{className} to assign specific style to elements, instead of \mintinline{html}{class} used in HTML.

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               breaklines=true,
               linenos]{jsx}
import "./StyleDemo.css";
import React, { Component } from "react";

export default class StyleAComponent extends Component {
  render() {
    return (
      <>
        <div className="small">Hola Mundo</div>
        <div className="big">Hola Mundo</div>
      </>
    );
  }
}
\end{minted}

This component will paint on the browser two squares, one green and small and the other red and bigger. You might need to choose between different styles based on a \mintinline{jsx}{prop} value:

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               breaklines=true,
               linenos]{jsx}
import React from "react";
import ReactDOM from "react-dom";
import StyleAComponent from "./StyleAComponent";

ReactDOM.render(
  <React.StrictMode>
    <StyleAComponent square="small" />
    <StyleAComponent square="big" />
  </React.StrictMode>,
  document.getElementById("root")
);
\end{minted}

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               breaklines=true,
               linenos]{jsx}
import "./StyleDemo.css";
import React, { Component } from "react";

export default class StyleAComponent extends Component {
  constructor(props) {
    super(props);
  }

  render() {
    return (
      <>
        <div className={this.props.square}>Hola Mundo</div>
      </>
    );
  }
}
\end{minted}

While not recommended, you can also use inline styling. The style attribute of JSX elements accepts a JavaScript object with camelCased properties, as demostrated below:


\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               breaklines=true,
               linenos]{jsx}
import React, { Component } from "react";

export default class StyleInLine extends Component {
  constructor(props) {
    super(props);
  }

  render() {
    const colorBoxStyle = {
      width: "50px",
      height: "50px",
      border: "1px solid rgba(0, 0, 0, 0.05)",
      backgroundColor: this.props.color,
    };

    return (
      <>
        <div style={colorBoxStyle}>Hola Mundo</div>
      </>
    );
  }
}
\end{minted}



\section{Props}

In React you can pass arguments to components. These arguments are transformed into a single JavaScript object with a special name: \mintinline{jsx}{props} (which stands for properties). Let's add to our class based Person component the usage of props:

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               breaklines=true,
               highlightlines={7},                              
               linenos]{jsx}
export default class Person extends Component {
  render() {
    return (
      <>
        My name is 
        <strong> 
         {this.props.name + " " + this.props.surname}
        </strong>
      </>
    );
  }
}
\end{minted}

And now the equivalent but using the function definition of the component:

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               breaklines=true,
               highlightlines={5},                              
               linenos]{jsx}
export default function Person(props) {
  return (
    <>
      My name is 
      <strong> {props.name + " " + props.surname}</strong>
    </>
  );
}
\end{minted}

\begin{displayquote}
{\small You might note the use of an empty tag \mintinline{jsx}{<>...</>} in the components definition above. React component must always return an element. That force you to wrap everything into a root element and usually for these cases we use the \mintinline{jsx}{<div>} element as our root. But that introduce an extra node in the DOM. That is why React introduced what is called \href{https://reactjs.org/docs/fragments.html}{fragments}.}
\end{displayquote}

Note that in our Person component, the \mintinline{jsx}{props} object has two properties: \mintinline{jsx}{name} and \mintinline{jsx}{surname}. In the class based component we accessed to them using \mintinline{jsx}{this.props} and in function based component just use the argument of the function.
\newline

How do you then pass \mintinline{jsx}{name} and \mintinline{jsx}{surname} to the component? You have to define them as JSX attributes, lets see that below:

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               breaklines=true,
               highlightlines={7},                              
               linenos]{jsx}
import React from "react";
import ReactDOM from "react-dom";
import Person from "./Person";

ReactDOM.render(
  <React.StrictMode>
   <Person name="Enrique" surname="Molinari" />
  </React.StrictMode>,
  document.getElementById("root")
);
\end{minted}

When React sees attributes in a user-defined component, like what we have on line 7 above, it passes them as the single object \mintinline{jsx}{props}.

\begin{displayquote}
{\small If you define a \mintinline{jsx}{constructor} in a class-based component, the constructor must receive \mintinline{jsx}{props} as argument and the first implementation line must be \mintinline{jsx}{super(props)}}.
\end{displayquote}


%los hijos se pasan como la propiedad especial children

\section{State} \label{state_section}
%State and Components Lifecycle
Suppose that we want to build a CountDownLatch component. Starting from a positive integer, on each second it is decremented until arrives to zero. Using what we have learned so far, we can create the component below:

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               breaklines=true,
               linenos]{jsx}
import React, { Component } from "react";

export default class CountDownLatch extends Component {
  render() {
    return <h1>{this.props.startFrom}</h1>;
  }
}
\end{minted}

The component just paint the property \mintinline{jsx}{props.startFrom} wrapped in an \mintinline{html}{<h1>} tag on the browser. Then on the \mintinline{console}{src/index.js} we can do something like this:

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               breaklines=true,
               linenos]{jsx}
import React from "react";
import ReactDOM from "react-dom";
import CountDownLatch from "./CountDownLatch";

function countDown(number) {
  ReactDOM.render(
    <React.StrictMode>
      <CountDownLatch startFrom={number} />
    </React.StrictMode>,
    document.getElementById("root")
  );
  if (number === 0) {
    clearInterval(intervalId);
  }
}

let startFrom = 10;
let intervalId = setInterval(() => {
  countDown(startFrom);
  startFrom = startFrom - 1;
}, 1000);
\end{minted}

The function on line 5, render the CountDownLatch component on the browser passing the number to be painted as props. Then we have starting on line 17 the \mintinline{jsx}{setInterval} JavasScript function which execute the arrow function (lines 19 and 20) every second. So, every second, the CountDownLatch component is repainted on the browser, each time with a the number passed as prop decremented by one. Until it arrives to zero where the \mintinline{jsx}{clearIntervale()} is executed stopping the count down.
\newline 

However, in the way we have implemented this, the logic that does the decrements, update the browser every second and stop the count down is outside the component. We can implement our component in a much better way incorporating the logic \textit{inside} the component. This will give us a much more reusable CountDownLatch component. In order to do this we must add \textbf{state} to our component. The \textbf{state} in React components is not like classic state you know from objects in the object oriented paradigm. React components \textit{react} to state changes performing the render again. Lets see how we add state to our CountDownLatch component:

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               breaklines=true,
               highlightlines={6,7,8,12},                              
               linenos]{jsx}
import React, { Component } from "react";

export default class CountDownLatch extends Component {
  constructor(props) {
    super(props);
    this.state = {
      startNumber: this.props.startFrom,
    };
  }

  render() {
    return <h1>{this.state.startNumber}</h1>;
  }
}
\end{minted}
 
\mintinline{jsx}{state} is managed and controlled by the component. On line 12, we have changed the use of props in \mintinline{jsx}{this.props.startNumber}, to the use of \mintinline{jsx}{state}. And on the constructor starting on line 4, we are initializing the \mintinline{jsx}{state} with the value from the \mintinline{jsx}{props} comming from a JSX attribute. Note that \mintinline{jsx}{state} is a JavaScript object, but with special meaning for React. Then on the \mintinline{console}{src/index.js} we add the JSX elements to paint our component on the browser:

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               breaklines=true,
               linenos]{jsx}
import React from "react";
import ReactDOM from "react-dom";
import CountDownLatch from "./CountDownLatch";

ReactDOM.render(
  <React.StrictMode>
    <CountDownLatch startFrom={10} />
  </React.StrictMode>,
  document.getElementById("root")
);
\end{minted}

As you can see on line 7 we are passing the value \mintinline{jsx}{10} as \mintinline{jsx}{props} which is used to initialize the \mintinline{jsx}{state} in the component's constructor. So far, if we run this, we will have just this markup \mintinline{jsx}{<h1>10</h1>} painted on the browser. Now we have to add the logic that decrements our number. To do this, we will take advantages from what React calls \textbf{lifecycle} methods. These methods are present only in class-based components and they are hooks that you can use plug your logic. Calling them hooks can be confused because React Hooks is a big new topic that we will cover in the next section, but in object oriented frameworks literature hooks are called to those extension points that you have to customise the framework. And this is exactly that, they are a set of methods that React calls at \textit{certain moments} and you can use to implement component's specific logic.
\newline

On of these lifecycle method that we will use is \mintinline{jsx}{componentDidMount()}. This method is called by React after the \mintinline{jsx}{constructor} is executed and after \mintinline{jsx}{render} is executed. So, it is called just after our component is rendered into the DOM for the first time. It is called the \textit{mounting} moment. This seems to be the perfect moment to set up the \mintinline{jsx}{setInterval} that performs the decrement. Let's see how this looks:

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               breaklines=true,
               linenos]{jsx}
import React, { Component } from "react";

export default class CountDownLatch extends Component {
  constructor(props) {
    super(props);
    this.state = {
      startNumber: this.props.startFrom,
    };
  }

  componentDidMount() {
    this.intervalId = setInterval(() => {
      this.setState((state) => ({
        startNumber: state.startNumber - 1,
      }));
    }, 1000);
  }
  
  render() {
    return <h1>{this.state.startNumber}</h1>;
  }
}
\end{minted}

On line 11 we have added the method \mintinline{jsx}{componentDidMount()} where we use to set up the decrement of the component. Note that each second the arrow function, passed as the first argument of the \mintinline{jsx}{setInterval} function, that decrements the \mintinline{jsx}{state.startNumber} by one is executed. To update the state we have to use the special \mintinline{jsx}{this.setState()} method, which triggers the \textit{re-render} of the component. So, on each second the \mintinline{jsx}{this.state.startNumber} is decremented by one and the component is painted again on the screen.
\newline

What is still missing in our component is to stop the countdown when it arrives to zero. To implement this, we have use another lifecycle method called \mintinline{jsx}{componentDidUpdate(prevProps, prevState)}. This method is executed when there is an update on the \mintinline{jsx}{state} of the component, after render again the component on the DOM. By  parameter receives the previous values from the props and the previous value from the state. Lets add then the logic to stop the countdown on this method to finishing our component.

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               breaklines=true,
               linenos]{jsx}
import React, { Component } from "react";

export default class CountDownLatch extends Component {
  constructor(props) {
    super(props);
    this.state = {
      startNumber: this.props.startFrom,
    };
  }

  componentDidMount() {
    this.intervalId = setInterval(() => {
      this.setState((state) => ({
        startNumber: state.startNumber - 1,
      }));
    }, 1000);
  }

  componentDidUpdate() {
    if (this.state.startNumber === 0) {
      clearInterval(this.intervalId);
    }
  }
  
  render() {
    return <h1>{this.state.startNumber}</h1>;
  }
}
\end{minted}

On line 19 above, we have added the lifecycle method \mintinline{jsx}{componentDidUpdate()}. As we can see on figure \ref{fig:lifecy}, after the mounting phase is finished, we have the updating phase, triggered by calling the \mintinline{jsx}{setState()} method, which first invoke the \mintinline{jsx}{render} and after that the \mintinline{jsx}{componentDidUpdate()}. There, if we arrive to zero we stop the countdown by calling the \mintinline{jsx}{clearInterval()} function. Remember that the arrow function we have set up in the \mintinline{jsx}{setInterval()} on the \mintinline{jsx}{componentDidMount()} method will be executed every second, triggering the updating phase each time due to the call to the \mintinline{jsx}{setState()} method.

\begin{figure}[htbp]
  \centering
  \includesvg{lifecycle1}
  \caption{Order of execution of lifecycle methods used in the CountDownLatch component}
   \label{fig:lifecy}
\end{figure}

We have seen how to use state and the lifecycle methods to create a self-encapsulated and reusable component. And we have reviewed how changes in component's state triggers the updating phase which among other things, re-render of the components on the browser. There are some more lifecycle methods in React. Dan Abramov has shared a picture to summarize all the \href{https://twitter.com/dan_abramov/status/981712092611989509/photo/1}{lifecycle methods} available. Note from the picture that there is a third phase called unmounting. That phase has a single  lifecycle method called \mintinline{jsx}{componentWillUnmount()} which is executed before the component is unmounted from the DOM. This method is used for clean up or close resources: subscriptions, sockets, timers, etc.
\newline

Few important notes to manage state in the correct way.

\begin{itemize}
  \item The constructor is the only place where you can change the state directly. In all other places use \mintinline{jsx}{setState()}.
  \begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               breaklines=true,
               linenos]{jsx}
//only do this inside constructor               
this.state.startNumber = 4;
\end{minted}
  \item \href{https://reactjs.org/docs/state-and-lifecycle.html}{State Updates may be asyc}: React may batch multiple \mintinline{jsx}{setState()} calls into a single update for performance. Because \mintinline{jsx}{this.props} and \mintinline{jsx}{this.state} may be updated asynchronously, you should not rely on their values for calculating the next state. In our CountDownLatch component we are updating the state on line 14 based on their previous value. In these cases you should not trust on the state current value. Use the one passed as argument on the setState() method, like below:
\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               breaklines=true,
               linenos]{jsx}
//Don't do this
this.setState(() => ({
  startNumber: this.state.startNumber - 1,
}));

//Do this
this.setState((state, props) => ({
  startNumber: state.startNumber - 1,
}));
\end{minted}
  \item In the \mintinline{jsx}{componentDidUpdate(prevProps, prevState)} lifecycle method you might need to call the \mintinline{jsx}{setState()} method. But make sure you wrap that call in a condition to avoid an infinite loop. Usually, the condition is based from the previous values of the props and/or state with the current values of them.
\end{itemize}

%si llamamos a setState en compodidupdate hay que poner condicion para no causar loop infinito
%https://reactjs.org/docs/react-component.html

\section{Dealing with Events}

Defining events in React is not that different from defining them on HTML. The big different is that in React you define the events on JSX, which is then translated to JavaScript, so there are two important things you should know:

\begin{itemize}
 \item Event names in JSX are defined in camelCase.
 \item You have to pass a function to handling the event. 
\end{itemize}

Look at the example below:

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               breaklines=true,
               linenos]{jsx}
<button onClick={clickMe}>Click me</button>
\end{minted}

Note that the event name \mintinline{jsx}{onClick} is written in camelCase. As we have mentioned, in JSX between curly braces you can define any valid JavaScript expression. In this case we are passing the function \mintinline{jsx}{clickMe} to be used to handling the event. As we have seen in section \ref{functions}, functions are first-class citizens in JavaScript allowing us to do that. Let's create a function based component to use some events:

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               breaklines=true,
               linenos]{jsx}
export default function EventExample() {
  function onOver() {
    console.log("onOver...");
  }

  function clickmeLink(e) {
    //this is necesary to prevent the default
    //link behavior
    e.preventDefault();
    console.log("link clicked...");
  }

  return (
    <div>
      {/*events are camelCase*/}
      {/*and they receive a function not a string*/}
      <a href="#" onMouseOver={onOver} onClick={clickmeLink}>
        click this link
      </a>
    </div>
  );
}
\end{minted}

On lines 2 and 6 we are defining the functions to handle the events \mintinline{jsx}{onClick} and \mintinline{jsx}{onMouseOver}, which just print on the console some text. Note that on the function \mintinline{jsx}{clickmeLink(e)} on line 6 we are receiving as argument an instance of the event, but is not the browser's native event, it is an instance of \href{https://reactjs.org/docs/events.html}{SyntheticEvent}, a React wrapper to make events works identically across browsers. And in this case we use it to prevent the default behaviour of clicking an anchor element.
\newline

Now, lets see how this example can be translated into a class based component:

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               breaklines=true,
               linenos]{jsx}
import React, { Component } from "react";

export default class EventExample extends Component {
  constructor(props) {
    super(props);
    this.onOver = this.onOver.bind(this);
    this.clickmeLink = this.clickmeLink.bind(this);
  }

  onOver() {
    console.log("onOver...");
  }

  clickmeLink(e) {
    //this is necesary to prevent the default
    //link behavior
    e.preventDefault();
    console.log("link clicked...");
  }

  render() {
    return (
      <div>
        {/*events are camelCase*/}
        {/*and they receive a function not a string*/}
        <a href="#" onMouseOver={this.onOver} onClick={this.clickmeLink}>
          click this link
        </a>
      </div>
    );
  }
}
\end{minted}

Since event handlers are class methods, on line 26 we can see that they are passed using \mintinline{jsx}{this}. However, as we have explained in section \ref{meaning_of_this}, if we assign or pass as an argument a method, we lose the binding of \mintinline{jsx}{this}, in this case, to the component instance. That is why we have to explicitly set this binding as we do on lines 6 and 7. Other than that, it is pretty similar to what we did on the function based component. 
\newline

Here is another example, in this case we change the state on the event handler:

\begin{minted}[fontseries=mc,
               framesep=5mm,
               frame=leftline,
               framerule=0.1pt,
               breaklines=true,
               linenos]{jsx}
import React, { Component } from "react";

export default class ColorSelect extends Component {
  constructor(props) {
    super(props);
    this.state = {
      value: "white",
    };
    this.colorChanged = this.colorChanged.bind(this);
  }

  colorChanged(e) {
    this.setState({
      value: e.target.value,
    });
  }

  render() {
    const colorBoxStyle = {
      width: "30px",
      height: "30px",
      border: "1px solid rgba(0, 0, 0, 0.05)",
      backgroundColor: this.state.value,
    };

    return (
      <>
        <label for="colors">Choose your favourite color: </label>
        <select name="colors" onChange={this.colorChanged}>
          <option>Options...</option>
          <option value="blue">Blue</option>
          <option value="red">Red</option>
          <option value="green">Green</option>
          <option value="yellow">Yellow</option>
        </select>
        <div style={colorBoxStyle}></div>
      </>
    );
  }
}
\end{minted}

In the example above we have a drop down list with colors. When you choose one color, the \mintinline{jsx}{onChange} event (line 29) is triggered, calling the method \mintinline{jsx}{colorChanged()} (line 12). The \mintinline{jsx}{state} gets updated with the color selected. Changing the state makes the render to be executed, painting the square box (line 36) now colored with the chosen color.

It is important to clarify that React is very efficient in updating the DOM. Only the exact portion of the DOM that has changed is the one that is updated. The rest remain untouched. You can check what I'm saying by running this component inspecting the DOM with the Browser DevTool. This is achieved by React using what is called as \href{https://reactjs.org/docs/faq-internals.html}{Virtual DOM} and the \href{https://reactjs.org/docs/reconciliation.html}{reconciliation}.
\newline

We will look at more events later on the book. Here is the full list of \href{https://reactjs.org/docs/events.html#reference}{supported events}.


\begin{thebibliography}{100} % 100 is a random guess of the total number of
%references
\bibitem{mozilla} \url{https://developer.mozilla.org/en-US/docs/Web/JavaScript}
\bibitem{ecma} \url{https://www.ecma-international.org/}
\bibitem{node} \url{https://nodejs.org/}
\bibitem{requirejs} \url{https://requirejs.org/}
\bibitem{loupe} \url{http://latentflip.com/loupe/}
\end{thebibliography}



\end{document}
%token 1c5334cb5d68999c16e3dda57848c4dccbe61c83
